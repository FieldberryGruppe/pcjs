Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-1
                                                            

                                	title	int14.asm 
                                	page	,120 
                                 
                                ;	By Jeff Parsons (@jeffpar) 2018-03-06 
                                ;	Installs interrupt handlers for the specified COM port 
                                 
 = 0001                         DEBUG	equ	1 
                                 
 0000                           code	segment word public 'code' 
                                 
 0100                           	org	100h 
                                 
                                	assume	cs:code, ds:code, es:code, ss:code 
                                 
 0100                           main	proc	near 
 0100  E9 092D R                	jmp	install 
                                main	endp 
                                 
                                	assume	cs:code, ds:nothing, es:nothing, ss:nothing 
                                 
 0103  90                       	even 
 0104  00 00 00 00              prev14	dd	0			; previous INT 14h handler 
 0108  01                       rtsFlg	db	1			; internal RTS flag (0=off, 1=on) 
 0109  00                       pollFlg	db	0			; polling mode (0=off, 1=on); set by /P 
 010A  00                       echoFlg	db	0			; set if incoming Ctrl-E has turned echo on 
                                 
 010B  90                       	even 
 010C  FFFF                     comID	dw	-1			; 0-based index of COM port in BIOS data area 
 010E  0003                     comIRQ	dw	3 
 0110  02F8                     comAddr	dw	2F8h 
                                 
 = 0020                         MAXBUF	equ	32 
 0112  0020[                    inBuf	db	MAXBUF dup (?) 
            ??                  
                         ]      
                                
 0132  0020[                    outBuf	db	MAXBUF dup (?) 
            ??                  
                         ]      
                                
 0152  0000                     inTot	dw	0			; counts the total number of input bytes buffered 
 0154  0112 R                   inHead	dw	offset inBuf 
 0156  0112 R                   inTail	dw	offset inBuf 
 0158  0132 R                   outHead	dw	offset outBuf 
 015A  0132 R                   outTail	dw	offset outBuf 
                                 
 = 0400                         MAXLOG	equ	1024 
 015C  0400[                    logBuff	db	MAXLOG dup (0) 
            00                  
                         ]      
                                
 055C  015C R                   logNext	dw	offset logBuff 
                                 
                                log	macro	c,d 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-2
                                                            

                                	local	log1 
                                	push	bx 
                                	mov	bx,logNext 
                                	mov	byte ptr cs:[bx],c 
                                	mov	byte ptr cs:[bx+1],d 
                                	add	bx,2 
                                	cmp	bx,offset logBuff + MAXLOG 
                                	jb	log1 
                                	mov	bx,offset logBuff 
                                log1:	mov	byte ptr cs:[bx],'.' 
                                	mov	byte ptr cs:[bx+1],'.' 
                                	mov	logNext,bx 
                                	pop	bx 
                                	endm 
                                 
 055E                           int14	proc	far 
 055E  2E: 3B 16 010C R         	cmp	dx,comID		; request for our COM port? 
 0563  74 03                    	je	i14a			; yes 
 0565  EB 55 90                 	jmp	i14x			; no 
                                 
 0568  84 E4                    i14a:	test	ah,ah			; INIT function? 
 056A  75 2D                    	jne	i14b			; no 
                                	log	'N',al 
 056C  53                     1 	push	bx
 056D  2E: 8B 1E 055C R       1 	mov	bx,logNext
 0572  2E: C6 07 4E           1 	mov	byte ptr cs:[bx],'N'
 0576  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 057A  83 C3 02               1 	add	bx,2
 057D  81 FB 055C R           1 	cmp	bx,offset logBuff + MAXLOG
 0581  72 03                  1 	jb	??0000
 0583  BB 015C R              1 	mov	bx,offset logBuff
 0586  2E: C6 07 2E           1 ??0000:	mov	byte ptr cs:[bx],'.'
 058A  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 058F  2E: 89 1E 055C R       1 	mov	logNext,bx
 0594  5B                     1 	pop	bx
 0595  E8 072A R                	call	init 
 0598  CF                       	iret 
                                 
 0599  80 FC 01                 i14b:	cmp	ah,1			; WRITE function? 
 059C  75 04                    	jne	i14c			; no 
                                ;	log	'W',al 
 059E  E8 0771 R                	call	write			; add the character in AL to outBuf 
 05A1  CF                       	iret 
                                 
 05A2  80 FC 02                 i14c:	cmp	ah,2			; READ function? 
 05A5  75 04                    	jne	i14d			; no 
 05A7  E8 07E3 R                	call	read			; remove next char from inBuf into AL 
                                ;	log	'R',al 
                                ;	log	'r',ah 
 05AA  CF                       	iret 
                                 
 05AB  80 FC 03                 i14d:	cmp	ah,3			; STATUS function? 
 05AE  75 04                    	jne	i14e			; no, jump to previous handler 
 05B0  E8 084A R                	call	status 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-3
                                                            

                                ;	log	'S',al			; these generate too much "noise" 
                                ;	log	's',ah 
 05B3  CF                       	iret 
                                 
 05B4  80 FC AA                 i14e:	cmp	ah,0AAh			; quick-and-dirty installation check 
 05B7  75 03                    	jne	i14x 
 05B9  F6 D4                    	not	ah 
 05BB  CF                       	iret 
                                 
 05BC  2E: FF 2E 0104 R         i14x:	jmp	dword ptr [prev14] 
                                 
                                int14	endp 
                                 
                                ; 
                                ; fakeLSR 
                                ; 
                                ; Returns fake LSR in AL. 
                                ; 
 05C1                           fakeLSR	proc	near 
                                	assume	ds:code 
 05C1  53                       	push	bx 
 05C2  52                       	push	dx 
 05C3  83 C2 05                 	add	dx,5			; DX -> LSR 
 05C6  EC                       	in	al,dx 
                                	; 
                                	; See if inBuf contains data, and set the DR bit if it does. 
                                	; 
 05C7  24 FE                    	and	al,not 01h 
 05C9  8B 1E 0154 R             	mov	bx,inHead 
 05CD  3B 1E 0156 R             	cmp	bx,inTail 
 05D1  74 02                    	je	lsr1 
 05D3  0C 01                    	or	al,01h 
                                	; 
                                	; See if outBuf still has room, and set the THRE bit if it does. 
                                	; 
 05D5  80 3E 0109 R 00          lsr1:	cmp	pollFlg,0 
 05DA  75 11                    	jne	lsr9 
 05DC  24 DF                    	and	al,not 20h 
 05DE  8B 1E 0158 R             	mov	bx,outHead 
 05E2  E8 065E R                	call	incPtr 
 05E5  3B 1E 015A R             	cmp	bx,outTail 
 05E9  74 02                    	je	lsr9 
 05EB  0C 20                    	or	al,20h 
                                 
 05ED  5A                       lsr9:	pop	dx 
 05EE  5B                       	pop	bx 
 05EF  C3                       	ret 
                                fakeLSR	endp 
                                 
                                ; 
                                ; getLSR 
                                ; 
                                ; Returns LSR in AL. 
                                ; 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-4
                                                            

 05F0                           getLSR	proc	near 
                                	assume	ds:code 
 05F0  52                       	push	dx 
 05F1  83 C2 05                 	add	dx,5			; DX -> LSR 
 05F4  EC                       	in	al,dx			; AL = LSR bits 
 05F5  5A                       	pop	dx 
 05F6  C3                       	ret 
                                getLSR	endp 
                                 
                                ; 
                                ; getMSR 
                                ; 
                                ; Returns MSR in AL. 
                                ; 
 05F7                           getMSR	proc	near 
                                	assume	ds:code 
 05F7  52                       	push	dx 
 05F8  83 C2 06                 	add	dx,6			; DX -> MSR 
 05FB  EC                       	in	al,dx			; AL = MSR bits 
 05FC  5A                       	pop	dx 
 05FD  C3                       	ret 
                                getMSR	endp 
                                 
                                ; 
                                ; setIER 
                                ; 
                                ; Sets the physical IER bits. 
                                ; 
 05FE                           setIER	proc	near 
                                	assume	ds:code 
 05FE  52                       	push	dx 
 05FF  83 C2 03                 	add	dx,3			; DX -> LCR 
 0602  EC                       	in	al,dx 
 0603  EB 00                    	jmp	$+2 
 0605  24 7F                    	and	al,not 80h		; make sure the DLAB is not set, so that we can set IER 
 0607  EE                       	out	dx,al 
 0608  4A                       	dec	dx 
 0609  4A                       	dec	dx			; DX -> IER 
 060A  B0 03                    	mov	al,03h			; enable RBR (01h) and THR (02h) COM interrupts 
 060C  EE                       	out	dx,al 
 060D  5A                       	pop	dx 
 060E  C3                       	ret 
                                setIER	endp 
                                 
                                ; 
                                ; setDTR 
                                ; 
                                ; Sets the physical DTR bit. 
                                ; 
 060F                           setDTR	proc	near 
                                	assume	ds:code 
 060F  52                       	push	dx 
 0610  83 C2 04                 	add	dx,4			; DX -> MCR 
 0613  EC                       	in	al,dx 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-5
                                                            

 0614  80 3E 0109 R 00          	cmp	pollFlg,0 
 0619  75 02                    	jne	dtr1 
 061B  0C 08                    	or	al,08h			; OUT2 == 08h (which apparently must ALSO be set enable interrupts) 
 061D  0C 01                    dtr1:	or	al,01h			; DTR == 01h 
 061F  EE                       	out	dx,al 
 0620  5A                       	pop	dx 
 0621  C3                       	ret 
                                setDTR	endp 
                                 
                                ; 
                                ; setRTS 
                                ; 
                                ; Sets the physical RTS bit according to the internal rtsFlg. 
                                ; 
 0622                           setRTS	proc	near 
                                	assume	ds:code 
 0622  50                       	push	ax 
 0623  52                       	push	dx 
 0624  83 C2 04                 	add	dx,4			; DX -> MCR 
 0627  EC                       	in	al,dx 
 0628  0C 02                    	or	al,02h			; RTS == 02h 
 062A  80 3E 0108 R 00          	cmp	rtsFlg,0 
 062F  75 02                    	jne	rts9 
 0631  24 FD                    	and	al,not 02h 
 0633  EE                       rts9:	out	dx,al 
                                	log	'T',al 
 0634  53                     1 	push	bx
 0635  8B 1E 055C R           1 	mov	bx,logNext
 0639  2E: C6 07 54           1 	mov	byte ptr cs:[bx],'T'
 063D  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 0641  83 C3 02               1 	add	bx,2
 0644  81 FB 055C R           1 	cmp	bx,offset logBuff + MAXLOG
 0648  72 03                  1 	jb	??0001
 064A  BB 015C R              1 	mov	bx,offset logBuff
 064D  2E: C6 07 2E           1 ??0001:	mov	byte ptr cs:[bx],'.'
 0651  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 0656  89 1E 055C R           1 	mov	logNext,bx
 065A  5B                     1 	pop	bx
 065B  5A                       	pop	dx 
 065C  58                       	pop	ax 
 065D  C3                       	ret 
                                setRTS	endp 
                                 
                                ; 
                                ; incPtr 
                                ; 
                                ; Updates BX to next buffer position. 
                                ; 
 065E                           incPtr	proc	near 
                                	assume	ds:code 
 065E  43                       	inc	bx 
 065F  81 FB 0132 R             	cmp	bx,offset inBuf + MAXBUF 
 0663  75 04                    	jne	inc1 
 0665  BB 0112 R                	mov	bx,offset inBuf 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-6
                                                            

 0668  C3                       inc0:	ret 
 0669  81 FB 0152 R             inc1:	cmp	bx,offset outBuf + MAXBUF 
 066D  75 F9                    	jne	inc0 
 066F  BB 0132 R                	mov	bx,offset outBuf 
 0672  C3                       	ret 
                                incPtr	endp 
                                 
                                ; 
                                ; tryIn 
                                ; 
                                ; If the DR bit is set, see if we can buffer the data. 
                                ; 
 0673                           tryIn	proc	near 
                                	assume	ds:code 
 0673  50                       	push	ax 
 0674  52                       	push	dx 
 0675  83 C2 05                 	add	dx,5			; DX -> LSR 
 0678  EC                       	in	al,dx 
 0679  5A                       	pop	dx 
 067A  A8 01                    	test	al,01h			; DR set? 
 067C  75 03                    	jnz	ti1			; yes 
 067E  E9 0707 R                	jmp	ti9 
 0681  EC                       ti1:	in	al,dx			; AL == new data 
                                	log	'I',al 
 0682  53                     1 	push	bx
 0683  8B 1E 055C R           1 	mov	bx,logNext
 0687  2E: C6 07 49           1 	mov	byte ptr cs:[bx],'I'
 068B  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 068F  83 C3 02               1 	add	bx,2
 0692  81 FB 055C R           1 	cmp	bx,offset logBuff + MAXLOG
 0696  72 03                  1 	jb	??0002
 0698  BB 015C R              1 	mov	bx,offset logBuff
 069B  2E: C6 07 2E           1 ??0002:	mov	byte ptr cs:[bx],'.'
 069F  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 06A4  89 1E 055C R           1 	mov	logNext,bx
 06A8  5B                     1 	pop	bx
 06A9  53                       	push	bx 
 06AA  8B 1E 0154 R             	mov	bx,inHead 
 06AE  88 07                    	mov	[bx],al 
 06B0  E8 065E R                	call	incPtr 
 06B3  3B 1E 0156 R             	cmp	bx,inTail 
 06B7  75 29                    	jne	ti7 
                                	log	'F',al 
 06B9  53                     1 	push	bx
 06BA  8B 1E 055C R           1 	mov	bx,logNext
 06BE  2E: C6 07 46           1 	mov	byte ptr cs:[bx],'F'
 06C2  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 06C6  83 C3 02               1 	add	bx,2
 06C9  81 FB 055C R           1 	cmp	bx,offset logBuff + MAXLOG
 06CD  72 03                  1 	jb	??0003
 06CF  BB 015C R              1 	mov	bx,offset logBuff
 06D2  2E: C6 07 2E           1 ??0003:	mov	byte ptr cs:[bx],'.'
 06D6  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 06DB  89 1E 055C R           1 	mov	logNext,bx
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-7
                                                            

 06DF  5B                     1 	pop	bx
 06E0  EB 24                    	jmp	short ti8		; buffer full, dropping the data 
 06E2  89 1E 0154 R             ti7:	mov	inHead,bx 
 06E6  FF 06 0152 R             	inc	inTot 
 06EA  80 3E 0109 R 00          	cmp	pollFlg,0 
 06EF  75 15                    	jne	ti8 
 06F1  83 3E 0152 R 18          	cmp	inTot,(MAXBUF/4)*3	; have we reached the 3/4 point? 
 06F6  75 0E                    	jne	ti8			; no 
 06F8  80 3E 0108 R 00          	cmp	rtsFlg,0		; is RTS already off? 
 06FD  74 07                    	je	ti8			; yes 
 06FF  FE 0E 0108 R             	dec	rtsFlg			; no, so let's try turning it off now 
 0703  E8 0622 R                	call	setRTS			; and hope the sender give us some space 
 0706  5B                       ti8:	pop	bx 
 0707  58                       ti9:	pop	ax 
 0708  C3                       	ret 
                                tryIn	endp 
                                 
                                ; 
                                ; tryOut 
                                ; 
                                ; If we have some buffered data, and the THRE bit is set, output more data. 
                                ; 
 0709                           tryOut	proc	near 
                                	assume	ds:code 
 0709  53                       	push	bx 
 070A  8B 1E 015A R             	mov	bx,outTail 
 070E  3B 1E 0158 R             	cmp	bx,outHead 
 0712  74 14                    	je	to9 
 0714  52                       	push	dx 
 0715  83 C2 05                 	add	dx,5			; DX -> LSR 
 0718  EC                       	in	al,dx 
 0719  5A                       	pop	dx 
 071A  A8 20                    	test	al,20h			; THRE set? 
 071C  74 0A                    	jz	to9			; no 
 071E  8A 07                    	mov	al,[bx] 
 0720  EE                       	out	dx,al 
                                ;	log	'O',al 
 0721  E8 065E R                	call	incPtr 
 0724  89 1E 015A R             	mov	outTail,bx 
 0728  5B                       to9:	pop	bx 
 0729  C3                       	ret 
                                tryOut	endp 
                                 
                                ; 
                                ; init 
                                ; 
                                ; Handles INIT requests from INT 14h. 
                                ; 
 072A                           init	proc	near 
 072A  53                       	push	bx 
 072B  52                       	push	dx 
 072C  1E                       	push	ds 
 072D  0E                       	push	cs 
 072E  1F                       	pop	ds 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-8
                                                            

                                	assume	ds:code 
 072F  9C                       	pushf 
 0730  FF 1E 0104 R             	call	dword ptr [prev14] 
 0734  50                       	push	ax 
 0735  8B 16 0110 R             	mov	dx,comAddr 
 0739  C7 06 0152 R 0000        	mov	inTot,0 
 073F  C7 06 0154 R 0112 R      	mov	inHead,offset inBuf 
 0745  C7 06 0156 R 0112 R      	mov	inTail,offset inBuf 
 074B  C7 06 0158 R 0132 R      	mov	outHead,offset outBuf 
 0751  C7 06 015A R 0132 R      	mov	outTail,offset outBuf 
 0757  80 3E 0109 R 00          	cmp	pollFlg,0 
 075C  75 03                    	jne	i1 
 075E  E8 05FE R                	call	setIER 
 0761  E8 060F R                i1:	call	setDTR 
 0764  C6 06 0108 R 01          	mov	rtsFlg,1 
 0769  E8 0622 R                	call	setRTS 
 076C  58                       	pop	ax 
 076D  1F                       	pop	ds 
                                	assume	ds:nothing 
 076E  5A                       	pop	dx 
 076F  5B                       	pop	bx 
 0770  C3                       	ret 
                                init	endp 
                                 
                                ; 
                                ; write 
                                ; 
                                ; Handles WRITE requests from INT 14h. 
                                ; 
                                ; If AH == 1 (the normal INT 14h write scenario), mimicking the ROM BIOS 
                                ; requires that we wait for DSR, then CTS, and finally THRE.  I would prefer 
                                ; to do that by spin-waiting for MSR-based and LSR-based interrupt triggers, 
                                ; rather than adopting the ROM's totally arbitrary "let's loop 64K times" for 
                                ; each condition.  But, as I'm sure the ROM BIOS authors originally thought 
                                ; too, this approach is easier. 
                                ; 
 0771                           write	proc	near 
 0771  53                       	push	bx 
 0772  51                       	push	cx 
 0773  52                       	push	dx 
 0774  1E                       	push	ds 
 0775  0E                       	push	cs 
 0776  1F                       	pop	ds 
                                	assume	ds:code 
 0777  8B 16 0110 R             	mov	dx,comAddr 
                                 
 077B  FB                       	sti 
                                 
                                	if	DEBUG 
 077C  80 3E 010A R 00          	cmp	echoFlg,0 
 0781  74 08                    	je	w0 
 0783  50                       	push	ax 
 0784  B4 0E                    	mov	ah,0Eh 
 0786  B7 00                    	mov	bh,0 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-9
                                                            

 0788  CD 10                    	int	10h 
 078A  58                       	pop	ax 
 078B                           w0: 
                                	endif 
                                 
 078B  86 E0                    	xchg	ah,al			; stash the output data in AH 
 078D  2B C9                    	sub	cx,cx 
 078F  E8 05F7 R                w1:	call	getMSR 
 0792  24 30                    	and	al,30h			; we're "cheating" and checking for both 
 0794  3C 30                    	cmp	al,30h			; DSR and CTS at once, instead of the ROM's 
 0796  74 0B                    	je	w2			; "one after the other" approach 
 0798  E2 F5                    	loop	w1 
 079A  E8 05F0 R                	call	getLSR 
 079D  0C 80                    	or	al,80h			; signal a time-out error 
 079F  86 E0                    	xchg	ah,al 
 07A1  EB 3B                    	jmp	short w9 
                                 
 07A3  80 3E 0109 R 00          w2:	cmp	pollFlg,0		; in polling mode, we take 
 07A8  74 03                    	je	w3			; every opportunity to check for input 
 07AA  E8 0673 R                	call	tryIn 
                                 
 07AD  2B C9                    w3:	sub	cx,cx 
 07AF  E8 05F0 R                w4:	call	getLSR 
 07B2  A8 20                    	test	al,20h			; checking THRE 
 07B4  75 08                    	jnz	w5 
 07B6  E2 F7                    	loop	w4 
 07B8  0C 80                    	or	al,80h			; signal a time-out error 
 07BA  86 E0                    	xchg	ah,al 
 07BC  EB 20                    	jmp	short w9 
                                 
 07BE  FA                       w5:	cli 
 07BF  2A C0                    	sub	al,al 
 07C1  86 C4                    	xchg	al,ah			; recover the output data in AL and zero AH 
 07C3  8B 1E 0158 R             	mov	bx,outHead 
 07C7  88 07                    	mov	[bx],al 
 07C9  E8 065E R                	call	incPtr 
 07CC  3B 1E 015A R             	cmp	bx,outTail 
 07D0  75 05                    	jne	w8 
 07D2  80 CC 80                 	or	ah,80h			; buffer full, so we pretend it's a time-out 
 07D5  EB 07                    	jmp	short w9 
                                 
 07D7  89 1E 0158 R             w8:	mov	outHead,bx		; there was room, so update the head ptr 
 07DB  E8 0709 R                	call	tryOut			; and since THRE was set, call tryOut 
                                 
 07DE  1F                       w9:	pop	ds 
                                	assume	ds:nothing 
 07DF  5A                       	pop	dx 
 07E0  59                       	pop	cx 
 07E1  5B                       	pop	bx 
 07E2  C3                       	ret 
                                write	endp 
                                 
                                ; 
                                ; read 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-10
                                                            

                                ; 
                                ; Handles READ requests from INT 14h. 
                                ; 
 07E3                           read	proc	near 
 07E3  53                       	push	bx 
 07E4  52                       	push	dx 
 07E5  1E                       	push	ds 
 07E6  0E                       	push	cs 
 07E7  1F                       	pop	ds 
                                	assume	ds:code 
 07E8  8B 16 0110 R             	mov	dx,comAddr 
                                 
 07EC  80 3E 0109 R 00          	cmp	pollFlg,0		; in polling mode, we take 
 07F1  74 0B                    	je	r1			; every opportunity to check for input 
 07F3  E8 0673 R                	call	tryIn 
 07F6  C6 06 0108 R 00          	mov	rtsFlg,0 
 07FB  E8 0622 R                	call	setRTS			; after a polled read, let's turn RTS off 
                                 
 07FE  2B C0                    r1:	sub	ax,ax 
 0800  E8 05C1 R                	call	fakeLSR 
 0803  8A E0                    	mov	ah,al 
                                 
 0805  8B 1E 0156 R             	mov	bx,inTail 
 0809  3B 1E 0154 R             	cmp	bx,inHead 
 080D  75 05                    	jne	r3 
 080F  80 CC 80                 	or	ah,80h 
 0812  EB 32                    	jmp	short r9 
                                 
 0814  8A 07                    r3:	mov	al,[bx] 
 0816  3C 05                    	cmp	al,05h			; Ctrl-E? 
 0818  75 05                    	jne	r4			; no 
 081A  80 36 010A R 01          	xor	echoFlg,1		; toggle echo flag 
 081F  E8 065E R                r4:	call	incPtr 
 0822  89 1E 0156 R             	mov	inTail,bx 
                                 
 0826  80 3E 0109 R 00          	cmp	pollFlg,0 
 082B  75 15                    	jne	r8 
 082D  83 3E 0152 R 08          	cmp	inTot,MAXBUF/4		; are we down to 1/4 full now? 
 0832  75 0E                    	jne	r8			; no 
 0834  80 3E 0108 R 00          	cmp	rtsFlg,0		; is RTS already on? 
 0839  75 07                    	jne	r8			; yes 
 083B  FE 06 0108 R             	inc	rtsFlg			; no, so let's turn RTS back on 
 083F  E8 0622 R                	call	setRTS 
 0842  FF 0E 0152 R             r8:	dec	inTot 
                                 
 0846  1F                       r9:	pop	ds 
                                	assume	ds:nothing 
 0847  5A                       	pop	dx 
 0848  5B                       	pop	bx 
 0849  C3                       	ret 
                                read	endp 
                                 
                                ; 
                                ; status 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-11
                                                            

                                ; 
                                ; Handles STATUS requests from INT 14h. 
                                ; 
                                ; We could pass STATUS requests on to the previous handler, but that would 
                                ; return the port's "raw" state, whereas we need to return our own simulated 
                                ; "buffered" state: LSR (reg #5) bits in AH, MSR (reg #6) bits in AL. 
                                ; 
                                ; It's worth noting what DOS really cares about from this call.  Prior to 
                                ; reading serial input, DOS calls the STATUS function and then requires that 
                                ; both AH bit 0 (LSR Data Ready: 0x01) and AL bit 5 (MSR Data Set Ready: 0x20) 
                                ; be set before it will call READ. 
                                ; 
                                ; Also, in some cases (eg, the CTTY case), DOS requires that both AH bit 5 
                                ; (LSR Transmitter Holding Register Empty: 0x20) and AL bit 5 (MSR Data Set 
                                ; Ready: 0x20) be set before it calls WRITE, while in other cases (eg, output 
                                ; redirection), DOS simply calls WRITE and hopes for the best. 
                                ; 
 084A                           status	proc	near 
 084A  53                       	push	bx 
 084B  52                       	push	dx 
 084C  1E                       	push	ds 
 084D  0E                       	push	cs 
 084E  1F                       	pop	ds 
                                	assume	ds:code 
 084F  8B 16 0110 R             	mov	dx,comAddr 
                                 
 0853  80 3E 0109 R 00          	cmp	pollFlg,0		; in polling mode, we take 
 0858  74 03                    	je	s1			; every opportunity to check for input 
 085A  E8 0673 R                	call	tryIn 
                                 
 085D  E8 05C1 R                s1:	call	fakeLSR 
 0860  8A E0                    	mov	ah,al			; AH = LSR bits 
 0862  E8 05F7 R                	call	getMSR			; AL = MSR bits 
                                 
 0865  80 3E 0109 R 00          	cmp	pollFlg,0 
 086A  74 0E                    	je	s9 
 086C  80 3E 0108 R 00          	cmp	rtsFlg,0		; in polling mode, if RTS isn't already on 
 0871  75 07                    	jne	s9			; turn it on 
 0873  FE 06 0108 R             	inc	rtsFlg 
 0877  E8 0622 R                	call	setRTS 
                                 
 087A  1F                       s9:	pop	ds 
                                	assume	ds:nothing 
 087B  5A                       	pop	dx 
 087C  5B                       	pop	bx 
 087D  C3                       	ret 
                                status	endp 
                                 
 087E                           intHW	proc	far 
 087E  FB                       	sti 
 087F  50                       	push	ax 
 0880  53                       	push	bx 
 0881  52                       	push	dx 
 0882  1E                       	push	ds 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-12
                                                            

 0883  0E                       	push	cs 
 0884  1F                       	pop	ds 
                                	assume	ds:code 
 0885  8B 16 0110 R             	mov	dx,comAddr 
                                 
 0889  52                       	push	dx 
 088A  42                       	inc	dx 
 088B  42                       	inc	dx			; DX -> IIR 
 088C  EC                       	in	al,dx 
 088D  5A                       	pop	dx 
                                	log	'H',al 
 088E  53                     1 	push	bx
 088F  8B 1E 055C R           1 	mov	bx,logNext
 0893  2E: C6 07 48           1 	mov	byte ptr cs:[bx],'H'
 0897  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 089B  83 C3 02               1 	add	bx,2
 089E  81 FB 055C R           1 	cmp	bx,offset logBuff + MAXLOG
 08A2  72 03                  1 	jb	??0004
 08A4  BB 015C R              1 	mov	bx,offset logBuff
 08A7  2E: C6 07 2E           1 ??0004:	mov	byte ptr cs:[bx],'.'
 08AB  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 08B0  89 1E 055C R           1 	mov	logNext,bx
 08B4  5B                     1 	pop	bx
                                 
 08B5  3C 02                    	cmp	al,02h			; THRE condition? 
 08B7  75 05                    	jne	hw1			; no 
 08B9  E8 0709 R                	call	tryOut			; yes, so see if we have something to write 
 08BC  EB 07                    	jmp	short hw9 
                                 
 08BE  3C 04                    hw1:	cmp	al,04h			; DR condition? 
 08C0  75 03                    	jne	hw9 
 08C2  E8 0673 R                	call	tryIn 
                                 
 08C5  FA                       hw9:	cli 
 08C6  B0 20                    	mov	al,20h			; EOI command 
 08C8  E6 20                    	out	20h,al 
                                 
 08CA  1F                       	pop	ds 
                                	assume	ds:nothing 
 08CB  5A                       	pop	dx 
 08CC  5B                       	pop	bx 
 08CD  58                       	pop	ax 
 08CE  CF                       	iret 
                                intHW	endp 
                                 
 08CF  90                       	even 
 08D0                           endRes	label	byte			; end of resident code/data 
                                 
 08D0  43 4F 4D 3F 20 68 61     comMsg	db	"COM? handlers installed$" 
       6E 64 6C 65 72 73 20     
       69 6E 73 74 61 6C 6C     
       65 64 24                 
 08E8  20 69 6E 20 70 6F 6C     pollMsg	db	" in polled mode$" 
       6C 65 64 20 6D 6F 64     
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-13
                                                            

       65 24                    
 08F8  0D 0A 24                 endMsg	db	13,10,'$' 
 08FB  48 61 6E 64 6C 65 72     insMsg	db	"Handlers already installed",13,10,'$' 
       73 20 61 6C 72 65 61     
       64 79 20 69 6E 73 74     
       61 6C 6C 65 64 0D 0A     
       24                       
 0918  43 4F 4D 20 70 6F 72     errMsg	db	"COM port not found",13,10,'$' 
       74 20 6E 6F 74 20 66     
       6F 75 6E 64 0D 0A 24     
                                 
 092D                           install	proc	near 
                                	assume	ds:code, es:code, ss:code 
                                	; 
                                	; Let's look for a /P switch to determine polled mode, 
                                	; along with /1 to select adapter #1 at port 3F8h instead of 2F8h. 
                                	; 
 092D  FC                       	cld 
 092E  BE 0080                  	mov	si,80h			; DS:SI -> command line 
 0931  AC                       	lodsb 
 0932  98                       	cbw 
 0933  91                       	xchg	cx,ax			; CX == line length (as a fail-safe) 
 0934  AC                       ins0:	lodsb 
 0935  49                       	dec	cx 
 0936  3C 0D                    	cmp	al,0Dh			; end of command-line? 
 0938  74 22                    	je	ins3			; yes 
 093A  3C 2F                    	cmp	al,'/' 
 093C  75 1A                    	jne	ins2 
 093E  AC                       	lodsb 
 093F  49                       	dec	cx 
 0940  3C 31                    	cmp	al,'1'			; /1? 
 0942  75 0A                    	jne	ins1			; no 
 0944  81 06 0110 R 0100        	add	comAddr,100h		; bump 2F8h to 3F8h 
 094A  FF 06 010E R             	inc	comIRQ			; bump IRQ3 to IRQ4 
 094E  24 DF                    ins1:	and	al,not 20h 
 0950  3C 50                    	cmp	al,'P'			; /P? 
 0952  75 04                    	jne	ins2			; no 
 0954  FE 06 0109 R             	inc	pollFlg			; yes, set pollFlg to non-zero 
 0958  85 C9                    ins2:	test	cx,cx			; any more command-line characters? 
 095A  7F D8                    	jg	ins0			; yes 
                                 
 095C  2B C0                    ins3:	sub	ax,ax 
 095E  8E C0                    	mov	es,ax 
                                	assume	es:nothing		; since ES is zero 
 0960  A1 0110 R                	mov	ax,comAddr 
                                 
 0963  BB 0400                  	mov	bx,400h			; access RBDA @0:400 instead of 40:0 
 0966  2B D2                    	sub	dx,dx 
 0968  26: 39 07                ins4:	cmp	word ptr es:[bx],ax	; matching port? 
 096B  74 11                    	je	ins5			; yes 
 096D  43                       	inc	bx 
 096E  43                       	inc	bx 
 096F  42                       	inc	dx 
 0970  80 FA 04                 	cmp	dl,4 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-14
                                                            

 0973  72 F3                    	jb	ins4 
 0975  BA 0918 R                	mov	dx,offset errMsg	; no matching port was found; abort 
 0978  B4 09                    	mov	ah,09h 
 097A  CD 21                    	int	21h 
 097C  CD 20                    	int	20h 
                                 
 097E  89 16 010C R             ins5:	mov	comID,dx		; comID is 0 for COM1, 1 for COM2, etc. 
 0982  B4 AA                    	mov	ah,0AAh			; quick-and-dirty installation check 
 0984  CD 14                    	int	14h 
 0986  F6 D4                    	not	ah 
 0988  80 FC AA                 	cmp	ah,0AAh 
 098B  75 09                    	jne	ins6 
 098D  BA 08FB R                	mov	dx,offset insMsg	; already installed for that port 
 0990  B4 09                    	mov	ah,09h 
 0992  CD 21                    	int	21h 
 0994  CD 20                    	int	20h			; abort 
                                 
 0996  B8 055E R                ins6:	mov	ax,offset int14 
 0999  26: 87 06 0050           	xchg	ax,es:[14h*4] 
 099E  A3 0104 R                	mov	word ptr prev14,ax 
 09A1  8C C8                    	mov	ax,cs 
 09A3  26: 87 06 0052           	xchg	ax,es:[14h*4+2] 
 09A8  A3 0106 R                	mov	word ptr prev14+2,ax 
                                 
 09AB  26: 8B 17                	mov	dx,es:[bx]		; DX is port (eg, 3F8h or 2F8h) 
 09AE  BB 087E R                	mov	bx,offset intHW 
 09B1  80 3E 0109 R 00          	cmp	pollFlg,0 
 09B6  75 28                    	jne	ins7 
 09B8  8B 3E 010E R             	mov	di,comIRQ		; convert IRQ... 
 09BC  83 C7 08                 	add	di,8			; ...to vector 
 09BF  03 FF                    	add	di,di			; and multiply vector by 4 
 09C1  03 FF                    	add	di,di 
 09C3  26: 89 1D                	mov	word ptr es:[di],bx 
 09C6  26: 8C 4D 02             	mov	es:[di+2],cs 
 09CA  E8 05FE R                	call	setIER 
 09CD  E4 21                    	in	al,21h 
 09CF  8A 0E 010E R             	mov	cl,byte ptr comIRQ 
 09D3  B4 01                    	mov	ah,1 
 09D5  D2 E4                    	shl	ah,cl 
 09D7  F6 D4                    	not	ah			; AH == NOT (1 SHL comIRQ) 
 09D9  22 C4                    	and	al,ah 
 09DB  E6 21                    	out	21h,al			; unmask the appropriate COM IRQ 
 09DD  BB 08D0 R                	mov	bx,offset endRes 
                                 
 09E0  E8 060F R                ins7:	call	setDTR			; set DTR (and OUT2 as needed for interrupts) 
 09E3  E8 0622 R                	call	setRTS			; rtsFlg is initially 1 
                                 
 09E6  8B 16 010C R             	mov	dx,comID 
 09EA  80 C2 31                 	add	dl,'1' 
 09ED  88 16 08D3 R             	mov	comMsg+3,dl 
 09F1  BA 08D0 R                	mov	dx,offset comMsg 
 09F4  B4 09                    	mov	ah,09h 
 09F6  CD 21                    	int	21h 
 09F8  80 3E 0109 R 00          	cmp	pollFlg,0 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Page     1-15
                                                            

 09FD  74 07                    	je	ins9 
 09FF  BA 08E8 R                	mov	dx,offset pollMsg 
 0A02  B4 09                    	mov	ah,09h 
 0A04  CD 21                    	int	21h 
 0A06  BA 08F8 R                ins9:	mov	dx,offset endMsg 
 0A09  B4 09                    	mov	ah,09h 
 0A0B  CD 21                    	int	21h 
                                 
 0A0D  8B D3                    	mov	dx,bx			; DX -> end of resident code/data 
 0A0F  CD 27                    	int	27h 
                                install	endp 
                                 
 0A11                           code	ends 
                                 
                                	end	main 

Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Symbols-1
                                                             

Macros:

		N a m e			Lines

LOG  . . . . . . . . . . . . . .  	  12

Segments and Groups:

                N a m e         	Size	Align	Combine Class

CODE . . . . . . . . . . . . . .  	0A11	WORD	PUBLIC	'CODE'

Symbols:            

                N a m e         	Type	Value	Attr         

COMADDR  . . . . . . . . . . . .  	L WORD 	0110	CODE
COMID  . . . . . . . . . . . . .  	L WORD 	010C	CODE
COMIRQ . . . . . . . . . . . . .  	L WORD 	010E	CODE
COMMSG . . . . . . . . . . . . .  	L BYTE 	08D0	CODE

DEBUG  . . . . . . . . . . . . .  	Number	0001	
DTR1 . . . . . . . . . . . . . .  	L NEAR	061D	CODE

ECHOFLG  . . . . . . . . . . . .  	L BYTE 	010A	CODE
ENDMSG . . . . . . . . . . . . .  	L BYTE 	08F8	CODE
ENDRES . . . . . . . . . . . . .  	L BYTE 	08D0	CODE
ERRMSG . . . . . . . . . . . . .  	L BYTE 	0918	CODE

FAKELSR  . . . . . . . . . . . .  	N PROC	05C1	CODE	Length = 002F

GETLSR . . . . . . . . . . . . .  	N PROC	05F0	CODE	Length = 0007
GETMSR . . . . . . . . . . . . .  	N PROC	05F7	CODE	Length = 0007

HW1  . . . . . . . . . . . . . .  	L NEAR	08BE	CODE
HW9  . . . . . . . . . . . . . .  	L NEAR	08C5	CODE

I1 . . . . . . . . . . . . . . .  	L NEAR	0761	CODE
I14A . . . . . . . . . . . . . .  	L NEAR	0568	CODE
I14B . . . . . . . . . . . . . .  	L NEAR	0599	CODE
I14C . . . . . . . . . . . . . .  	L NEAR	05A2	CODE
I14D . . . . . . . . . . . . . .  	L NEAR	05AB	CODE
I14E . . . . . . . . . . . . . .  	L NEAR	05B4	CODE
I14X . . . . . . . . . . . . . .  	L NEAR	05BC	CODE
INBUF  . . . . . . . . . . . . .  	L BYTE 	0112	CODE	Length = 0020
INC0 . . . . . . . . . . . . . .  	L NEAR	0668	CODE
INC1 . . . . . . . . . . . . . .  	L NEAR	0669	CODE
INCPTR . . . . . . . . . . . . .  	N PROC	065E	CODE	Length = 0015
INHEAD . . . . . . . . . . . . .  	L WORD 	0154	CODE
INIT . . . . . . . . . . . . . .  	N PROC	072A	CODE	Length = 0047
INS0 . . . . . . . . . . . . . .  	L NEAR	0934	CODE
INS1 . . . . . . . . . . . . . .  	L NEAR	094E	CODE
INS2 . . . . . . . . . . . . . .  	L NEAR	0958	CODE
INS3 . . . . . . . . . . . . . .  	L NEAR	095C	CODE
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Symbols-2
                                                             

INS4 . . . . . . . . . . . . . .  	L NEAR	0968	CODE
INS5 . . . . . . . . . . . . . .  	L NEAR	097E	CODE
INS6 . . . . . . . . . . . . . .  	L NEAR	0996	CODE
INS7 . . . . . . . . . . . . . .  	L NEAR	09E0	CODE
INS9 . . . . . . . . . . . . . .  	L NEAR	0A06	CODE
INSMSG . . . . . . . . . . . . .  	L BYTE 	08FB	CODE
INSTALL  . . . . . . . . . . . .  	N PROC	092D	CODE	Length = 00E4
INT14  . . . . . . . . . . . . .  	F PROC	055E	CODE	Length = 0063
INTAIL . . . . . . . . . . . . .  	L WORD 	0156	CODE
INTHW  . . . . . . . . . . . . .  	F PROC	087E	CODE	Length = 0051
INTOT  . . . . . . . . . . . . .  	L WORD 	0152	CODE

LOGBUFF  . . . . . . . . . . . .  	L BYTE 	015C	CODE	Length = 0400
LOGNEXT  . . . . . . . . . . . .  	L WORD 	055C	CODE
LSR1 . . . . . . . . . . . . . .  	L NEAR	05D5	CODE
LSR9 . . . . . . . . . . . . . .  	L NEAR	05ED	CODE

MAIN . . . . . . . . . . . . . .  	N PROC	0100	CODE	Length = 0003
MAXBUF . . . . . . . . . . . . .  	Number	0020	
MAXLOG . . . . . . . . . . . . .  	Number	0400	

OUTBUF . . . . . . . . . . . . .  	L BYTE 	0132	CODE	Length = 0020
OUTHEAD  . . . . . . . . . . . .  	L WORD 	0158	CODE
OUTTAIL  . . . . . . . . . . . .  	L WORD 	015A	CODE

POLLFLG  . . . . . . . . . . . .  	L BYTE 	0109	CODE
POLLMSG  . . . . . . . . . . . .  	L BYTE 	08E8	CODE
PREV14 . . . . . . . . . . . . .  	L DWORD	0104	CODE

R1 . . . . . . . . . . . . . . .  	L NEAR	07FE	CODE
R3 . . . . . . . . . . . . . . .  	L NEAR	0814	CODE
R4 . . . . . . . . . . . . . . .  	L NEAR	081F	CODE
R8 . . . . . . . . . . . . . . .  	L NEAR	0842	CODE
R9 . . . . . . . . . . . . . . .  	L NEAR	0846	CODE
READ . . . . . . . . . . . . . .  	N PROC	07E3	CODE	Length = 0067
RTS9 . . . . . . . . . . . . . .  	L NEAR	0633	CODE
RTSFLG . . . . . . . . . . . . .  	L BYTE 	0108	CODE

S1 . . . . . . . . . . . . . . .  	L NEAR	085D	CODE
S9 . . . . . . . . . . . . . . .  	L NEAR	087A	CODE
SETDTR . . . . . . . . . . . . .  	N PROC	060F	CODE	Length = 0013
SETIER . . . . . . . . . . . . .  	N PROC	05FE	CODE	Length = 0011
SETRTS . . . . . . . . . . . . .  	N PROC	0622	CODE	Length = 003C
STATUS . . . . . . . . . . . . .  	N PROC	084A	CODE	Length = 0034

TI1  . . . . . . . . . . . . . .  	L NEAR	0681	CODE
TI7  . . . . . . . . . . . . . .  	L NEAR	06E2	CODE
TI8  . . . . . . . . . . . . . .  	L NEAR	0706	CODE
TI9  . . . . . . . . . . . . . .  	L NEAR	0707	CODE
TO9  . . . . . . . . . . . . . .  	L NEAR	0728	CODE
TRYIN  . . . . . . . . . . . . .  	N PROC	0673	CODE	Length = 0096
TRYOUT . . . . . . . . . . . . .  	N PROC	0709	CODE	Length = 0021

W0 . . . . . . . . . . . . . . .  	L NEAR	078B	CODE
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 21:49:43

int14.asm                                                   Symbols-3
                                                             

W1 . . . . . . . . . . . . . . .  	L NEAR	078F	CODE
W2 . . . . . . . . . . . . . . .  	L NEAR	07A3	CODE
W3 . . . . . . . . . . . . . . .  	L NEAR	07AD	CODE
W4 . . . . . . . . . . . . . . .  	L NEAR	07AF	CODE
W5 . . . . . . . . . . . . . . .  	L NEAR	07BE	CODE
W8 . . . . . . . . . . . . . . .  	L NEAR	07D7	CODE
W9 . . . . . . . . . . . . . . .  	L NEAR	07DE	CODE
WRITE  . . . . . . . . . . . . .  	N PROC	0771	CODE	Length = 0072

??0000 . . . . . . . . . . . . .  	L NEAR	0586	CODE
??0001 . . . . . . . . . . . . .  	L NEAR	064D	CODE
??0002 . . . . . . . . . . . . .  	L NEAR	069B	CODE
??0003 . . . . . . . . . . . . .  	L NEAR	06D2	CODE
??0004 . . . . . . . . . . . . .  	L NEAR	08A7	CODE


    691 Source  Lines
    751 Total   Lines
    114 Symbols

  47060 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
