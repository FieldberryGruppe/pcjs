Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-1
                                                            

                                	title	int14.asm 
                                	page	,120 
                                 
                                ;	By Jeff Parsons (@jeffpar) 2018-03-06 
                                ;	Installs interrupt handlers for the COM port associated with I/O address 0x2F8 (and IR
				Q 3). 
                                 
 0000                           code	segment word public 'code' 
                                 
 0100                           	org	100h 
                                 
                                	assume	cs:code, ds:code, es:code, ss:code 
                                 
 0100                           main	proc	near 
 0100  E9 065D R                	jmp	install 
                                main	endp 
                                 
                                	assume	cs:code, ds:nothing, es:nothing, ss:nothing 
                                 
 0103  90                       	even 
 0104  00 00 00 00              prev14	dd	0			; previous INT 14h handler 
 0108  01                       rtsFlg	db	1			; internal RTS flag (0=off, 1=on) 
 0109  00                       pollFlg	db	0			; polling mode (0=off, 1=on); set by /P 
 010A  FFFF                     comID	dw	-1			; 0-based index of COM port in BIOS data area 
 010C  0003                     comIRQ	dw	3 
 010E  02F8                     comAddr	dw	2F8h 
                                 
 = 0010                         MAXBUF	equ	16 
 0110  0010[                    inBuf	db	MAXBUF dup (?) 
            ??                  
                         ]      
                                
 0120  0010[                    outBuf	db	MAXBUF dup (?) 
            ??                  
                         ]      
                                
 0130  0000                     inTot	dw	0			; counts the total number of input bytes buffered 
 0132  0110 R                   inHead	dw	offset inBuf 
 0134  0110 R                   inTail	dw	offset inBuf 
 0136  0120 R                   outHead	dw	offset outBuf 
 0138  0120 R                   outTail	dw	offset outBuf 
                                 
 = 0100                         MAXLOG	equ	256 
 013A  0100[                    logBuff	db	MAXLOG dup (0) 
            00                  
                         ]      
                                
 023A  013A R                   logNext	dw	offset logBuff 
                                 
                                log	macro	c,d 
                                	local	log1 
                                	push	bx 
                                	mov	bx,logNext 
                                	mov	byte ptr cs:[bx],c 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-2
                                                            

                                	mov	byte ptr cs:[bx+1],d 
                                	add	bx,2 
                                	cmp	bx,offset logBuff + MAXLOG 
                                	jb	log1 
                                	mov	bx,offset logBuff 
                                log1:	mov	byte ptr cs:[bx],'.' 
                                	mov	byte ptr cs:[bx+1],'.' 
                                	mov	logNext,bx 
                                	pop	bx 
                                	endm 
                                 
 023C                           int14	proc	far 
 023C  2E: 3B 16 010A R         	cmp	dx,comID		; request for our COM port? 
 0241  74 03                    	je	i14a			; yes 
 0243  E9 0315 R                	jmp	i14x			; no 
                                 
 0246  84 E4                    i14a:	test	ah,ah			; INIT function? 
 0248  75 2D                    	jne	i14b			; no 
                                	log	'N',al 
 024A  53                     1 	push	bx
 024B  2E: 8B 1E 023A R       1 	mov	bx,logNext
 0250  2E: C6 07 4E           1 	mov	byte ptr cs:[bx],'N'
 0254  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 0258  83 C3 02               1 	add	bx,2
 025B  81 FB 023A R           1 	cmp	bx,offset logBuff + MAXLOG
 025F  72 03                  1 	jb	??0000
 0261  BB 013A R              1 	mov	bx,offset logBuff
 0264  2E: C6 07 2E           1 ??0000:	mov	byte ptr cs:[bx],'.'
 0268  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 026D  2E: 89 1E 023A R       1 	mov	logNext,bx
 0272  5B                     1 	pop	bx
 0273  E8 0478 R                	call	init 
 0276  CF                       	iret 
                                 
 0277  80 FC 01                 i14b:	cmp	ah,1			; WRITE function? 
 027A  75 2D                    	jne	i14c			; no 
                                	log	'W',al 
 027C  53                     1 	push	bx
 027D  2E: 8B 1E 023A R       1 	mov	bx,logNext
 0282  2E: C6 07 57           1 	mov	byte ptr cs:[bx],'W'
 0286  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 028A  83 C3 02               1 	add	bx,2
 028D  81 FB 023A R           1 	cmp	bx,offset logBuff + MAXLOG
 0291  72 03                  1 	jb	??0001
 0293  BB 013A R              1 	mov	bx,offset logBuff
 0296  2E: C6 07 2E           1 ??0001:	mov	byte ptr cs:[bx],'.'
 029A  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 029F  2E: 89 1E 023A R       1 	mov	logNext,bx
 02A4  5B                     1 	pop	bx
 02A5  E8 04BF R                	call	write			; add the character in AL to outBuf 
 02A8  CF                       	iret 
                                 
 02A9  80 FC 02                 i14c:	cmp	ah,2			; READ function? 
 02AC  75 56                    	jne	i14d			; no 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-3
                                                            

 02AE  E8 0522 R                	call	read			; remove next char from inBuf into AL 
                                	log	'R',al 
 02B1  53                     1 	push	bx
 02B2  2E: 8B 1E 023A R       1 	mov	bx,logNext
 02B7  2E: C6 07 52           1 	mov	byte ptr cs:[bx],'R'
 02BB  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 02BF  83 C3 02               1 	add	bx,2
 02C2  81 FB 023A R           1 	cmp	bx,offset logBuff + MAXLOG
 02C6  72 03                  1 	jb	??0002
 02C8  BB 013A R              1 	mov	bx,offset logBuff
 02CB  2E: C6 07 2E           1 ??0002:	mov	byte ptr cs:[bx],'.'
 02CF  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 02D4  2E: 89 1E 023A R       1 	mov	logNext,bx
 02D9  5B                     1 	pop	bx
                                	log	'r',ah 
 02DA  53                     1 	push	bx
 02DB  2E: 8B 1E 023A R       1 	mov	bx,logNext
 02E0  2E: C6 07 72           1 	mov	byte ptr cs:[bx],'r'
 02E4  2E: 88 67 01           1 	mov	byte ptr cs:[bx+1],ah
 02E8  83 C3 02               1 	add	bx,2
 02EB  81 FB 023A R           1 	cmp	bx,offset logBuff + MAXLOG
 02EF  72 03                  1 	jb	??0003
 02F1  BB 013A R              1 	mov	bx,offset logBuff
 02F4  2E: C6 07 2E           1 ??0003:	mov	byte ptr cs:[bx],'.'
 02F8  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 02FD  2E: 89 1E 023A R       1 	mov	logNext,bx
 0302  5B                     1 	pop	bx
 0303  CF                       	iret 
                                 
 0304  80 FC 03                 i14d:	cmp	ah,3			; STATUS function? 
 0307  75 04                    	jne	i14e			; no, jump to previous handler 
 0309  E8 057A R                	call	status 
                                ;	log	'S',al			; these generate too much "noise" 
                                ;	log	's',ah 
 030C  CF                       	iret 
                                 
 030D  80 FC AA                 i14e:	cmp	ah,0AAh			; quick-and-dirty installation check 
 0310  75 03                    	jne	i14x 
 0312  F6 D4                    	not	ah 
 0314  CF                       	iret 
                                 
 0315  2E: FF 2E 0104 R         i14x:	jmp	dword ptr [prev14] 
                                 
                                int14	endp 
                                 
                                ; 
                                ; fakeLSR 
                                ; 
                                ; Returns fake LSR in AL. 
                                ; 
 031A                           fakeLSR	proc	near 
                                	assume	ds:code 
 031A  53                       	push	bx 
 031B  52                       	push	dx 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-4
                                                            

 031C  83 C2 05                 	add	dx,5			; DX -> LSR 
 031F  EC                       	in	al,dx 
                                	; 
                                	; See if inBuf contains data, and set the DR bit if it does. 
                                	; 
 0320  24 FE                    	and	al,not 01h 
 0322  8B 1E 0132 R             	mov	bx,inHead 
 0326  3B 1E 0134 R             	cmp	bx,inTail 
 032A  74 02                    	je	lsr1 
 032C  0C 01                    	or	al,01h 
                                	; 
                                	; See if outBuf still has room, and set the THRE bit if it does. 
                                	; 
 032E  80 3E 0109 R 00          lsr1:	cmp	pollFlg,0 
 0333  75 11                    	jne	lsr9 
 0335  24 DF                    	and	al,not 20h 
 0337  8B 1E 0136 R             	mov	bx,outHead 
 033B  E8 03B7 R                	call	incPtr 
 033E  3B 1E 0138 R             	cmp	bx,outTail 
 0342  74 02                    	je	lsr9 
 0344  0C 20                    	or	al,20h 
                                 
 0346  5A                       lsr9:	pop	dx 
 0347  5B                       	pop	bx 
 0348  C3                       	ret 
                                fakeLSR	endp 
                                 
                                ; 
                                ; getLSR 
                                ; 
                                ; Returns LSR in AL. 
                                ; 
 0349                           getLSR	proc	near 
                                	assume	ds:code 
 0349  52                       	push	dx 
 034A  83 C2 05                 	add	dx,5			; DX -> LSR 
 034D  EC                       	in	al,dx			; AL = LSR bits 
 034E  5A                       	pop	dx 
 034F  C3                       	ret 
                                getLSR	endp 
                                 
                                ; 
                                ; getMSR 
                                ; 
                                ; Returns MSR in AL. 
                                ; 
 0350                           getMSR	proc	near 
                                	assume	ds:code 
 0350  52                       	push	dx 
 0351  83 C2 06                 	add	dx,6			; DX -> MSR 
 0354  EC                       	in	al,dx			; AL = MSR bits 
 0355  5A                       	pop	dx 
 0356  C3                       	ret 
                                getMSR	endp 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-5
                                                            

                                 
                                ; 
                                ; setIER 
                                ; 
                                ; Sets the physical IER bits. 
                                ; 
 0357                           setIER	proc	near 
                                	assume	ds:code 
 0357  52                       	push	dx 
 0358  83 C2 03                 	add	dx,3			; DX -> LCR 
 035B  EC                       	in	al,dx 
 035C  EB 00                    	jmp	$+2 
 035E  24 7F                    	and	al,not 80h		; make sure the DLAB is not set, so that we can set IER 
 0360  EE                       	out	dx,al 
 0361  4A                       	dec	dx 
 0362  4A                       	dec	dx			; DX -> IER 
 0363  B0 03                    	mov	al,03h			; enable RBR (01h) and THR (02h) COM interrupts 
 0365  EE                       	out	dx,al 
 0366  5A                       	pop	dx 
 0367  C3                       	ret 
                                setIER	endp 
                                 
                                ; 
                                ; setDTR 
                                ; 
                                ; Sets the physical DTR bit. 
                                ; 
 0368                           setDTR	proc	near 
                                	assume	ds:code 
 0368  52                       	push	dx 
 0369  83 C2 04                 	add	dx,4			; DX -> MCR 
 036C  EC                       	in	al,dx 
 036D  80 3E 0109 R 00          	cmp	pollFlg,0 
 0372  75 02                    	jne	dtr1 
 0374  0C 08                    	or	al,08h			; OUT2 == 08h (which apparently must ALSO be set enable interrupts) 
 0376  0C 01                    dtr1:	or	al,01h			; DTR == 01h 
 0378  EE                       	out	dx,al 
 0379  5A                       	pop	dx 
 037A  C3                       	ret 
                                setDTR	endp 
                                 
                                ; 
                                ; setRTS 
                                ; 
                                ; Sets the physical RTS bit according to the internal rtsFlg. 
                                ; 
 037B                           setRTS	proc	near 
                                	assume	ds:code 
 037B  50                       	push	ax 
 037C  52                       	push	dx 
 037D  83 C2 04                 	add	dx,4			; DX -> MCR 
 0380  EC                       	in	al,dx 
 0381  0C 02                    	or	al,02h			; RTS == 02h 
 0383  80 3E 0108 R 00          	cmp	rtsFlg,0 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-6
                                                            

 0388  75 02                    	jne	rts9 
 038A  24 FD                    	and	al,not 02h 
 038C  EE                       rts9:	out	dx,al 
                                	log	'T',al 
 038D  53                     1 	push	bx
 038E  8B 1E 023A R           1 	mov	bx,logNext
 0392  2E: C6 07 54           1 	mov	byte ptr cs:[bx],'T'
 0396  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 039A  83 C3 02               1 	add	bx,2
 039D  81 FB 023A R           1 	cmp	bx,offset logBuff + MAXLOG
 03A1  72 03                  1 	jb	??0004
 03A3  BB 013A R              1 	mov	bx,offset logBuff
 03A6  2E: C6 07 2E           1 ??0004:	mov	byte ptr cs:[bx],'.'
 03AA  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 03AF  89 1E 023A R           1 	mov	logNext,bx
 03B3  5B                     1 	pop	bx
 03B4  5A                       	pop	dx 
 03B5  58                       	pop	ax 
 03B6  C3                       	ret 
                                setRTS	endp 
                                 
                                ; 
                                ; incPtr 
                                ; 
                                ; Updates BX to next buffer position. 
                                ; 
 03B7                           incPtr	proc	near 
                                	assume	ds:code 
 03B7  43                       	inc	bx 
 03B8  81 FB 0120 R             	cmp	bx,offset inBuf + MAXBUF 
 03BC  75 04                    	jne	inc1 
 03BE  BB 0110 R                	mov	bx,offset inBuf 
 03C1  C3                       inc0:	ret 
 03C2  81 FB 0130 R             inc1:	cmp	bx,offset outBuf + MAXBUF 
 03C6  75 F9                    	jne	inc0 
 03C8  BB 0120 R                	mov	bx,offset outBuf 
 03CB  C3                       	ret 
                                incPtr	endp 
                                 
                                ; 
                                ; tryIn 
                                ; 
                                ; If the DR bit is set, see if we can buffer the data. 
                                ; 
 03CC                           tryIn	proc	near 
                                	assume	ds:code 
 03CC  50                       	push	ax 
 03CD  52                       	push	dx 
 03CE  83 C2 05                 	add	dx,5			; DX -> LSR 
 03D1  EC                       	in	al,dx 
 03D2  5A                       	pop	dx 
 03D3  A8 01                    	test	al,01h			; DR set? 
 03D5  74 57                    	jz	ti9 
 03D7  EC                       	in	al,dx			; AL == new data 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-7
                                                            

                                	log	'I',al 
 03D8  53                     1 	push	bx
 03D9  8B 1E 023A R           1 	mov	bx,logNext
 03DD  2E: C6 07 49           1 	mov	byte ptr cs:[bx],'I'
 03E1  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 03E5  83 C3 02               1 	add	bx,2
 03E8  81 FB 023A R           1 	cmp	bx,offset logBuff + MAXLOG
 03EC  72 03                  1 	jb	??0005
 03EE  BB 013A R              1 	mov	bx,offset logBuff
 03F1  2E: C6 07 2E           1 ??0005:	mov	byte ptr cs:[bx],'.'
 03F5  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 03FA  89 1E 023A R           1 	mov	logNext,bx
 03FE  5B                     1 	pop	bx
 03FF  53                       	push	bx 
 0400  8B 1E 0132 R             	mov	bx,inHead 
 0404  88 07                    	mov	[bx],al 
 0406  E8 03B7 R                	call	incPtr 
 0409  3B 1E 0134 R             	cmp	bx,inTail 
 040D  74 1E                    	je	ti8			; buffer full, dropping the data 
 040F  89 1E 0132 R             	mov	inHead,bx 
 0413  FF 06 0130 R             	inc	inTot 
 0417  80 3E 0109 R 00          	cmp	pollFlg,0 
 041C  75 0F                    	jne	ti8 
 041E  83 3E 0130 R 08          	cmp	inTot,MAXBUF/2		; have we reached the half-way point? 
 0423  75 08                    	jne	ti8			; no 
 0425  C6 06 0108 R 00          	mov	rtsFlg,0		; yes, so let's try turning RTS off 
 042A  E8 037B R                	call	setRTS			; and hope the sender give us some space 
 042D  5B                       ti8:	pop	bx 
 042E  58                       ti9:	pop	ax 
 042F  C3                       	ret 
                                tryIn	endp 
                                 
                                ; 
                                ; tryOut 
                                ; 
                                ; If we have some buffered data, and the THRE bit is set, output more data. 
                                ; 
 0430                           tryOut	proc	near 
                                	assume	ds:code 
 0430  53                       	push	bx 
 0431  8B 1E 0138 R             	mov	bx,outTail 
 0435  3B 1E 0136 R             	cmp	bx,outHead 
 0439  74 3B                    	je	to9 
 043B  52                       	push	dx 
 043C  83 C2 05                 	add	dx,5			; DX -> LSR 
 043F  EC                       	in	al,dx 
 0440  5A                       	pop	dx 
 0441  A8 20                    	test	al,20h			; THRE set? 
 0443  74 31                    	jz	to9			; no 
 0445  8A 07                    	mov	al,[bx] 
 0447  EE                       	out	dx,al 
                                	log	'O',al 
 0448  53                     1 	push	bx
 0449  8B 1E 023A R           1 	mov	bx,logNext
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-8
                                                            

 044D  2E: C6 07 4F           1 	mov	byte ptr cs:[bx],'O'
 0451  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 0455  83 C3 02               1 	add	bx,2
 0458  81 FB 023A R           1 	cmp	bx,offset logBuff + MAXLOG
 045C  72 03                  1 	jb	??0006
 045E  BB 013A R              1 	mov	bx,offset logBuff
 0461  2E: C6 07 2E           1 ??0006:	mov	byte ptr cs:[bx],'.'
 0465  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 046A  89 1E 023A R           1 	mov	logNext,bx
 046E  5B                     1 	pop	bx
 046F  E8 03B7 R                	call	incPtr 
 0472  89 1E 0138 R             	mov	outTail,bx 
 0476  5B                       to9:	pop	bx 
 0477  C3                       	ret 
                                tryOut	endp 
                                 
                                ; 
                                ; init 
                                ; 
                                ; Handles INIT requests from INT 14h. 
                                ; 
 0478                           init	proc	near 
 0478  53                       	push	bx 
 0479  52                       	push	dx 
 047A  1E                       	push	ds 
 047B  0E                       	push	cs 
 047C  1F                       	pop	ds 
                                	assume	ds:code 
 047D  9C                       	pushf 
 047E  FF 1E 0104 R             	call	dword ptr [prev14] 
 0482  50                       	push	ax 
 0483  8B 16 010E R             	mov	dx,comAddr 
 0487  C7 06 0130 R 0000        	mov	inTot,0 
 048D  C7 06 0132 R 0110 R      	mov	inHead,offset inBuf 
 0493  C7 06 0134 R 0110 R      	mov	inTail,offset inBuf 
 0499  C7 06 0136 R 0120 R      	mov	outHead,offset outBuf 
 049F  C7 06 0138 R 0120 R      	mov	outTail,offset outBuf 
 04A5  80 3E 0109 R 00          	cmp	pollFlg,0 
 04AA  75 03                    	jne	i1 
 04AC  E8 0357 R                	call	setIER 
 04AF  E8 0368 R                i1:	call	setDTR 
 04B2  C6 06 0108 R 01          	mov	rtsFlg,1 
 04B7  E8 037B R                	call	setRTS 
 04BA  58                       	pop	ax 
 04BB  1F                       	pop	ds 
                                	assume	ds:nothing 
 04BC  5A                       	pop	dx 
 04BD  5B                       	pop	bx 
 04BE  C3                       	ret 
                                init	endp 
                                 
                                ; 
                                ; write 
                                ; 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-9
                                                            

                                ; Handles WRITE requests from INT 14h. 
                                ; 
                                ; If AH == 1 (the normal INT 14h write scenario), mimicking the ROM BIOS 
                                ; requires that we wait for DSR, then CTS, and finally THRE.  I would prefer 
                                ; to do that by spin-waiting for MSR-based and LSR-based interrupt triggers, 
                                ; rather than adopting the ROM's totally arbitrary "let's loop 64K times" for 
                                ; each condition.  But, as I'm sure the ROM BIOS authors originally thought 
                                ; too, this approach is easier. 
                                ; 
 04BF                           write	proc	near 
 04BF  53                       	push	bx 
 04C0  51                       	push	cx 
 04C1  52                       	push	dx 
 04C2  1E                       	push	ds 
 04C3  0E                       	push	cs 
 04C4  1F                       	pop	ds 
                                	assume	ds:code 
 04C5  8B 16 010E R             	mov	dx,comAddr 
                                 
 04C9  FB                       	sti 
 04CA  86 E0                    	xchg	ah,al			; stash the output data in AH 
 04CC  2B C9                    	sub	cx,cx 
 04CE  E8 0350 R                w1:	call	getMSR 
 04D1  24 30                    	and	al,30h			; we're "cheating" and checking for both 
 04D3  3C 30                    	cmp	al,30h			; DSR and CTS at once, instead of the ROM's 
 04D5  74 0B                    	je	w2			; "one after the other" approach 
 04D7  E2 F5                    	loop	w1 
 04D9  E8 0349 R                	call	getLSR 
 04DC  0C 80                    	or	al,80h			; signal a time-out error 
 04DE  86 E0                    	xchg	ah,al 
 04E0  EB 3B                    	jmp	short w9 
                                 
 04E2  80 3E 0109 R 00          w2:	cmp	pollFlg,0		; in polling mode, we take 
 04E7  74 03                    	je	w3			; every opportunity to check for input 
 04E9  E8 03CC R                	call	tryIn 
                                 
 04EC  2B C9                    w3:	sub	cx,cx 
 04EE  E8 0349 R                w4:	call	getLSR 
 04F1  A8 20                    	test	al,20h			; checking THRE 
 04F3  75 08                    	jnz	w5 
 04F5  E2 F7                    	loop	w4 
 04F7  0C 80                    	or	al,80h			; signal a time-out error 
 04F9  86 E0                    	xchg	ah,al 
 04FB  EB 20                    	jmp	short w9 
                                 
 04FD  FA                       w5:	cli 
 04FE  2A C0                    	sub	al,al 
 0500  86 C4                    	xchg	al,ah			; recover the output data in AL and zero AH 
 0502  8B 1E 0136 R             	mov	bx,outHead 
 0506  88 07                    	mov	[bx],al 
 0508  E8 03B7 R                	call	incPtr 
 050B  3B 1E 0138 R             	cmp	bx,outTail 
 050F  75 05                    	jne	w8 
 0511  80 CC 80                 	or	ah,80h			; buffer full, so we pretend it's a time-out 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-10
                                                            

 0514  EB 07                    	jmp	short w9 
                                 
 0516  89 1E 0136 R             w8:	mov	outHead,bx		; there was room, so update the head ptr 
 051A  E8 0430 R                	call	tryOut			; and since THRE was set, call tryOut 
                                 
 051D  1F                       w9:	pop	ds 
                                	assume	ds:nothing 
 051E  5A                       	pop	dx 
 051F  59                       	pop	cx 
 0520  5B                       	pop	bx 
 0521  C3                       	ret 
                                write	endp 
                                 
                                ; 
                                ; read 
                                ; 
                                ; Handles READ requests from INT 14h. 
                                ; 
 0522                           read	proc	near 
 0522  53                       	push	bx 
 0523  52                       	push	dx 
 0524  1E                       	push	ds 
 0525  0E                       	push	cs 
 0526  1F                       	pop	ds 
                                	assume	ds:code 
 0527  8B 16 010E R             	mov	dx,comAddr 
                                 
 052B  80 3E 0109 R 00          	cmp	pollFlg,0		; in polling mode, we take 
 0530  74 0B                    	je	r1			; every opportunity to check for input 
 0532  E8 03CC R                	call	tryIn 
 0535  C6 06 0108 R 00          	mov	rtsFlg,0 
 053A  E8 037B R                	call	setRTS			; after a polled read, let's turn RTS off 
                                 
 053D  2B C0                    r1:	sub	ax,ax 
 053F  E8 031A R                	call	fakeLSR 
 0542  8A E0                    	mov	ah,al 
                                 
 0544  8B 1E 0134 R             	mov	bx,inTail 
 0548  3B 1E 0132 R             	cmp	bx,inHead 
 054C  75 05                    	jne	r3 
 054E  80 CC 80                 	or	ah,80h 
 0551  EB 23                    	jmp	short r9 
                                 
 0553  8A 07                    r3:	mov	al,[bx] 
 0555  E8 03B7 R                	call	incPtr 
 0558  89 1E 0134 R             	mov	inTail,bx 
                                 
 055C  80 3E 0109 R 00          	cmp	pollFlg,0 
 0561  75 0F                    	jne	r4 
 0563  83 3E 0130 R 08          	cmp	inTot,MAXBUF/2		; are we at the half-way point? 
 0568  75 08                    	jne	r4			; no 
 056A  C6 06 0108 R 01          	mov	rtsFlg,1		; yes, so we must have turned RTS off 
 056F  E8 037B R                	call	setRTS			; so let's turn RTS back on 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-11
                                                            

 0572  FF 0E 0130 R             r4:	dec	inTot 
                                 
 0576  1F                       r9:	pop	ds 
                                	assume	ds:nothing 
 0577  5A                       	pop	dx 
 0578  5B                       	pop	bx 
 0579  C3                       	ret 
                                read	endp 
                                 
                                ; 
                                ; status 
                                ; 
                                ; Handles STATUS requests from INT 14h. 
                                ; 
                                ; We could pass STATUS requests on to the previous handler, but that would 
                                ; return the port's "raw" state, whereas we need to return our own simulated 
                                ; "buffered" state: LSR (reg #5) bits in AH, MSR (reg #6) bits in AL. 
                                ; 
                                ; It's worth noting what DOS really cares about from this call.  Prior to 
                                ; reading serial input, DOS calls the STATUS function and then requires that 
                                ; both AH bit 0 (LSR Data Ready: 0x01) and AL bit 5 (MSR Data Set Ready: 0x20) 
                                ; be set before it will call READ. 
                                ; 
                                ; Also, in some cases (eg, the CTTY case), DOS requires that both AH bit 5 
                                ; (LSR Transmitter Holding Register Empty: 0x20) and AL bit 5 (MSR Data Set 
                                ; Ready: 0x20) be set before it calls WRITE, while in other cases (eg, output 
                                ; redirection), DOS simply calls WRITE and hopes for the best. 
                                ; 
 057A                           status	proc	near 
 057A  53                       	push	bx 
 057B  52                       	push	dx 
 057C  1E                       	push	ds 
 057D  0E                       	push	cs 
 057E  1F                       	pop	ds 
                                	assume	ds:code 
 057F  8B 16 010E R             	mov	dx,comAddr 
                                 
 0583  80 3E 0109 R 00          	cmp	pollFlg,0		; in polling mode, we take 
 0588  74 03                    	je	s1			; every opportunity to check for input 
 058A  E8 03CC R                	call	tryIn 
                                 
 058D  E8 031A R                s1:	call	fakeLSR 
 0590  8A E0                    	mov	ah,al			; AH = LSR bits 
 0592  E8 0350 R                	call	getMSR			; AL = MSR bits 
                                 
 0595  80 3E 0109 R 00          	cmp	pollFlg,0 
 059A  74 0E                    	je	s9 
 059C  80 3E 0108 R 00          	cmp	rtsFlg,0		; in polling mode, if RTS isn't already on 
 05A1  75 07                    	jne	s9			; turn it on 
 05A3  FE 06 0108 R             	inc	rtsFlg 
 05A7  E8 037B R                	call	setRTS 
                                 
 05AA  1F                       s9:	pop	ds 
                                	assume	ds:nothing 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-12
                                                            

 05AB  5A                       	pop	dx 
 05AC  5B                       	pop	bx 
 05AD  C3                       	ret 
                                status	endp 
                                 
 05AE                           intHW	proc	far 
 05AE  FB                       	sti 
 05AF  50                       	push	ax 
 05B0  53                       	push	bx 
 05B1  52                       	push	dx 
 05B2  1E                       	push	ds 
 05B3  0E                       	push	cs 
 05B4  1F                       	pop	ds 
                                	assume	ds:code 
 05B5  8B 16 010E R             	mov	dx,comAddr 
                                 
 05B9  52                       	push	dx 
 05BA  42                       	inc	dx 
 05BB  42                       	inc	dx			; DX -> IIR 
 05BC  EC                       	in	al,dx 
 05BD  5A                       	pop	dx 
                                	log	'H',al 
 05BE  53                     1 	push	bx
 05BF  8B 1E 023A R           1 	mov	bx,logNext
 05C3  2E: C6 07 48           1 	mov	byte ptr cs:[bx],'H'
 05C7  2E: 88 47 01           1 	mov	byte ptr cs:[bx+1],al
 05CB  83 C3 02               1 	add	bx,2
 05CE  81 FB 023A R           1 	cmp	bx,offset logBuff + MAXLOG
 05D2  72 03                  1 	jb	??0007
 05D4  BB 013A R              1 	mov	bx,offset logBuff
 05D7  2E: C6 07 2E           1 ??0007:	mov	byte ptr cs:[bx],'.'
 05DB  2E: C6 47 01 2E        1 	mov	byte ptr cs:[bx+1],'.'
 05E0  89 1E 023A R           1 	mov	logNext,bx
 05E4  5B                     1 	pop	bx
                                 
 05E5  3C 02                    	cmp	al,02h			; THRE condition? 
 05E7  75 05                    	jne	hw1			; no 
 05E9  E8 0430 R                	call	tryOut			; yes, so see if we have something to write 
 05EC  EB 07                    	jmp	short hw9 
                                 
 05EE  3C 04                    hw1:	cmp	al,04h			; DR condition? 
 05F0  75 03                    	jne	hw9 
 05F2  E8 03CC R                	call	tryIn 
                                 
 05F5  FA                       hw9:	cli 
 05F6  B0 20                    	mov	al,20h			; EOI command 
 05F8  E6 20                    	out	20h,al 
                                 
 05FA  1F                       	pop	ds 
                                	assume	ds:nothing 
 05FB  5A                       	pop	dx 
 05FC  5B                       	pop	bx 
 05FD  58                       	pop	ax 
 05FE  CF                       	iret 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-13
                                                            

                                intHW	endp 
                                 
 05FF  90                       	even 
 0600                           endRes	label	byte			; end of resident code/data 
                                 
 0600  43 4F 4D 3F 20 68 61     comMsg	db	"COM? handlers installed$" 
       6E 64 6C 65 72 73 20     
       69 6E 73 74 61 6C 6C     
       65 64 24                 
 0618  20 69 6E 20 70 6F 6C     pollMsg	db	" in polled mode$" 
       6C 65 64 20 6D 6F 64     
       65 24                    
 0628  0D 0A 24                 endMsg	db	13,10,'$' 
 062B  48 61 6E 64 6C 65 72     insMsg	db	"Handlers already installed",13,10,'$' 
       73 20 61 6C 72 65 61     
       64 79 20 69 6E 73 74     
       61 6C 6C 65 64 0D 0A     
       24                       
 0648  43 4F 4D 20 70 6F 72     errMsg	db	"COM port not found",13,10,'$' 
       74 20 6E 6F 74 20 66     
       6F 75 6E 64 0D 0A 24     
                                 
 065D                           install	proc	near 
                                	assume	ds:code, es:code, ss:code 
                                	; 
                                	; Let's look for a /P switch to determine polled mode, 
                                	; along with /1 to select adapter #1 at port 3F8h instead of 2F8h. 
                                	; 
 065D  FC                       	cld 
 065E  BE 0080                  	mov	si,80h			; DS:SI -> command line 
 0661  AC                       	lodsb 
 0662  98                       	cbw 
 0663  91                       	xchg	cx,ax			; CX == line length (as a fail-safe) 
 0664  AC                       ins0:	lodsb 
 0665  49                       	dec	cx 
 0666  3C 0D                    	cmp	al,0Dh			; end of command-line? 
 0668  74 22                    	je	ins3			; yes 
 066A  3C 2F                    	cmp	al,'/' 
 066C  75 1A                    	jne	ins2 
 066E  AC                       	lodsb 
 066F  49                       	dec	cx 
 0670  3C 31                    	cmp	al,'1'			; /1? 
 0672  75 0A                    	jne	ins1			; no 
 0674  81 06 010E R 0100        	add	comAddr,100h		; bump 2F8h to 3F8h 
 067A  FF 06 010C R             	inc	comIRQ			; bump IRQ3 to IRQ4 
 067E  24 DF                    ins1:	and	al,not 20h 
 0680  3C 50                    	cmp	al,'P'			; /P? 
 0682  75 04                    	jne	ins2			; no 
 0684  FE 06 0109 R             	inc	pollFlg			; yes, set pollFlg to non-zero 
 0688  85 C9                    ins2:	test	cx,cx			; any more command-line characters? 
 068A  7F D8                    	jg	ins0			; yes 
                                 
 068C  2B C0                    ins3:	sub	ax,ax 
 068E  8E C0                    	mov	es,ax 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-14
                                                            

                                	assume	es:nothing		; since ES is zero 
 0690  A1 010E R                	mov	ax,comAddr 
                                 
 0693  BB 0400                  	mov	bx,400h			; access RBDA @0:400 instead of 40:0 
 0696  2B D2                    	sub	dx,dx 
 0698  26: 39 07                ins4:	cmp	word ptr es:[bx],ax	; matching port? 
 069B  74 11                    	je	ins5			; yes 
 069D  43                       	inc	bx 
 069E  43                       	inc	bx 
 069F  42                       	inc	dx 
 06A0  80 FA 04                 	cmp	dl,4 
 06A3  72 F3                    	jb	ins4 
 06A5  BA 0648 R                	mov	dx,offset errMsg	; no matching port was found; abort 
 06A8  B4 09                    	mov	ah,09h 
 06AA  CD 21                    	int	21h 
 06AC  CD 20                    	int	20h 
                                 
 06AE  89 16 010A R             ins5:	mov	comID,dx		; comID is 0 for COM1, 1 for COM2, etc. 
 06B2  B4 AA                    	mov	ah,0AAh			; quick-and-dirty installation check 
 06B4  CD 14                    	int	14h 
 06B6  F6 D4                    	not	ah 
 06B8  80 FC AA                 	cmp	ah,0AAh 
 06BB  75 09                    	jne	ins6 
 06BD  BA 062B R                	mov	dx,offset insMsg	; already installed for that port 
 06C0  B4 09                    	mov	ah,09h 
 06C2  CD 21                    	int	21h 
 06C4  CD 20                    	int	20h			; abort 
                                 
 06C6  B8 023C R                ins6:	mov	ax,offset int14 
 06C9  26: 87 06 0050           	xchg	ax,es:[14h*4] 
 06CE  A3 0104 R                	mov	word ptr prev14,ax 
 06D1  8C C8                    	mov	ax,cs 
 06D3  26: 87 06 0052           	xchg	ax,es:[14h*4+2] 
 06D8  A3 0106 R                	mov	word ptr prev14+2,ax 
                                 
 06DB  26: 8B 17                	mov	dx,es:[bx]		; DX is port (eg, 3F8h or 2F8h) 
 06DE  BB 05AE R                	mov	bx,offset intHW 
 06E1  80 3E 0109 R 00          	cmp	pollFlg,0 
 06E6  75 28                    	jne	ins7 
 06E8  8B 3E 010C R             	mov	di,comIRQ		; convert IRQ... 
 06EC  83 C7 08                 	add	di,8			; ...to vector 
 06EF  03 FF                    	add	di,di			; and multiply vector by 4 
 06F1  03 FF                    	add	di,di 
 06F3  26: 89 1D                	mov	word ptr es:[di],bx 
 06F6  26: 8C 4D 02             	mov	es:[di+2],cs 
 06FA  E8 0357 R                	call	setIER 
 06FD  E4 21                    	in	al,21h 
 06FF  8A 0E 010C R             	mov	cl,byte ptr comIRQ 
 0703  B4 01                    	mov	ah,1 
 0705  D2 E4                    	shl	ah,cl 
 0707  F6 D4                    	not	ah			; AH == NOT (1 SHL comIRQ) 
 0709  22 C4                    	and	al,ah 
 070B  E6 21                    	out	21h,al			; unmask the appropriate COM IRQ 
 070D  BB 0600 R                	mov	bx,offset endRes 
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Page     1-15
                                                            

                                 
 0710  E8 0368 R                ins7:	call	setDTR			; set DTR (and OUT2 as needed for interrupts) 
 0713  E8 037B R                	call	setRTS			; rtsFlg is initially 1 
                                 
 0716  8B 16 010A R             	mov	dx,comID 
 071A  80 C2 31                 	add	dl,'1' 
 071D  88 16 0603 R             	mov	comMsg+3,dl 
 0721  BA 0600 R                	mov	dx,offset comMsg 
 0724  B4 09                    	mov	ah,09h 
 0726  CD 21                    	int	21h 
 0728  80 3E 0109 R 00          	cmp	pollFlg,0 
 072D  74 07                    	je	ins9 
 072F  BA 0618 R                	mov	dx,offset pollMsg 
 0732  B4 09                    	mov	ah,09h 
 0734  CD 21                    	int	21h 
 0736  BA 0628 R                ins9:	mov	dx,offset endMsg 
 0739  B4 09                    	mov	ah,09h 
 073B  CD 21                    	int	21h 
                                 
 073D  8B D3                    	mov	dx,bx			; DX -> end of resident code/data 
 073F  CD 27                    	int	27h 
                                install	endp 
                                 
 0741                           code	ends 
                                 
                                	end	main 

Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Symbols-1
                                                             

Macros:

		N a m e			Lines

LOG  . . . . . . . . . . . . . .  	  12

Segments and Groups:

                N a m e         	Size	Align	Combine Class

CODE . . . . . . . . . . . . . .  	0741	WORD	PUBLIC	'CODE'

Symbols:            

                N a m e         	Type	Value	Attr         

COMADDR  . . . . . . . . . . . .  	L WORD 	010E	CODE
COMID  . . . . . . . . . . . . .  	L WORD 	010A	CODE
COMIRQ . . . . . . . . . . . . .  	L WORD 	010C	CODE
COMMSG . . . . . . . . . . . . .  	L BYTE 	0600	CODE

DTR1 . . . . . . . . . . . . . .  	L NEAR	0376	CODE

ENDMSG . . . . . . . . . . . . .  	L BYTE 	0628	CODE
ENDRES . . . . . . . . . . . . .  	L BYTE 	0600	CODE
ERRMSG . . . . . . . . . . . . .  	L BYTE 	0648	CODE

FAKELSR  . . . . . . . . . . . .  	N PROC	031A	CODE	Length = 002F

GETLSR . . . . . . . . . . . . .  	N PROC	0349	CODE	Length = 0007
GETMSR . . . . . . . . . . . . .  	N PROC	0350	CODE	Length = 0007

HW1  . . . . . . . . . . . . . .  	L NEAR	05EE	CODE
HW9  . . . . . . . . . . . . . .  	L NEAR	05F5	CODE

I1 . . . . . . . . . . . . . . .  	L NEAR	04AF	CODE
I14A . . . . . . . . . . . . . .  	L NEAR	0246	CODE
I14B . . . . . . . . . . . . . .  	L NEAR	0277	CODE
I14C . . . . . . . . . . . . . .  	L NEAR	02A9	CODE
I14D . . . . . . . . . . . . . .  	L NEAR	0304	CODE
I14E . . . . . . . . . . . . . .  	L NEAR	030D	CODE
I14X . . . . . . . . . . . . . .  	L NEAR	0315	CODE
INBUF  . . . . . . . . . . . . .  	L BYTE 	0110	CODE	Length = 0010
INC0 . . . . . . . . . . . . . .  	L NEAR	03C1	CODE
INC1 . . . . . . . . . . . . . .  	L NEAR	03C2	CODE
INCPTR . . . . . . . . . . . . .  	N PROC	03B7	CODE	Length = 0015
INHEAD . . . . . . . . . . . . .  	L WORD 	0132	CODE
INIT . . . . . . . . . . . . . .  	N PROC	0478	CODE	Length = 0047
INS0 . . . . . . . . . . . . . .  	L NEAR	0664	CODE
INS1 . . . . . . . . . . . . . .  	L NEAR	067E	CODE
INS2 . . . . . . . . . . . . . .  	L NEAR	0688	CODE
INS3 . . . . . . . . . . . . . .  	L NEAR	068C	CODE
INS4 . . . . . . . . . . . . . .  	L NEAR	0698	CODE
INS5 . . . . . . . . . . . . . .  	L NEAR	06AE	CODE
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Symbols-2
                                                             

INS6 . . . . . . . . . . . . . .  	L NEAR	06C6	CODE
INS7 . . . . . . . . . . . . . .  	L NEAR	0710	CODE
INS9 . . . . . . . . . . . . . .  	L NEAR	0736	CODE
INSMSG . . . . . . . . . . . . .  	L BYTE 	062B	CODE
INSTALL  . . . . . . . . . . . .  	N PROC	065D	CODE	Length = 00E4
INT14  . . . . . . . . . . . . .  	F PROC	023C	CODE	Length = 00DE
INTAIL . . . . . . . . . . . . .  	L WORD 	0134	CODE
INTHW  . . . . . . . . . . . . .  	F PROC	05AE	CODE	Length = 0051
INTOT  . . . . . . . . . . . . .  	L WORD 	0130	CODE

LOGBUFF  . . . . . . . . . . . .  	L BYTE 	013A	CODE	Length = 0100
LOGNEXT  . . . . . . . . . . . .  	L WORD 	023A	CODE
LSR1 . . . . . . . . . . . . . .  	L NEAR	032E	CODE
LSR9 . . . . . . . . . . . . . .  	L NEAR	0346	CODE

MAIN . . . . . . . . . . . . . .  	N PROC	0100	CODE	Length = 0003
MAXBUF . . . . . . . . . . . . .  	Number	0010	
MAXLOG . . . . . . . . . . . . .  	Number	0100	

OUTBUF . . . . . . . . . . . . .  	L BYTE 	0120	CODE	Length = 0010
OUTHEAD  . . . . . . . . . . . .  	L WORD 	0136	CODE
OUTTAIL  . . . . . . . . . . . .  	L WORD 	0138	CODE

POLLFLG  . . . . . . . . . . . .  	L BYTE 	0109	CODE
POLLMSG  . . . . . . . . . . . .  	L BYTE 	0618	CODE
PREV14 . . . . . . . . . . . . .  	L DWORD	0104	CODE

R1 . . . . . . . . . . . . . . .  	L NEAR	053D	CODE
R3 . . . . . . . . . . . . . . .  	L NEAR	0553	CODE
R4 . . . . . . . . . . . . . . .  	L NEAR	0572	CODE
R9 . . . . . . . . . . . . . . .  	L NEAR	0576	CODE
READ . . . . . . . . . . . . . .  	N PROC	0522	CODE	Length = 0058
RTS9 . . . . . . . . . . . . . .  	L NEAR	038C	CODE
RTSFLG . . . . . . . . . . . . .  	L BYTE 	0108	CODE

S1 . . . . . . . . . . . . . . .  	L NEAR	058D	CODE
S9 . . . . . . . . . . . . . . .  	L NEAR	05AA	CODE
SETDTR . . . . . . . . . . . . .  	N PROC	0368	CODE	Length = 0013
SETIER . . . . . . . . . . . . .  	N PROC	0357	CODE	Length = 0011
SETRTS . . . . . . . . . . . . .  	N PROC	037B	CODE	Length = 003C
STATUS . . . . . . . . . . . . .  	N PROC	057A	CODE	Length = 0034

TI8  . . . . . . . . . . . . . .  	L NEAR	042D	CODE
TI9  . . . . . . . . . . . . . .  	L NEAR	042E	CODE
TO9  . . . . . . . . . . . . . .  	L NEAR	0476	CODE
TRYIN  . . . . . . . . . . . . .  	N PROC	03CC	CODE	Length = 0064
TRYOUT . . . . . . . . . . . . .  	N PROC	0430	CODE	Length = 0048

W1 . . . . . . . . . . . . . . .  	L NEAR	04CE	CODE
W2 . . . . . . . . . . . . . . .  	L NEAR	04E2	CODE
W3 . . . . . . . . . . . . . . .  	L NEAR	04EC	CODE
W4 . . . . . . . . . . . . . . .  	L NEAR	04EE	CODE
W5 . . . . . . . . . . . . . . .  	L NEAR	04FD	CODE
W8 . . . . . . . . . . . . . . .  	L NEAR	0516	CODE
Microsoft (R) Macro Assembler  Version 4.00                 3/14/18 15:33:52

int14.asm                                                   Symbols-3
                                                             

W9 . . . . . . . . . . . . . . .  	L NEAR	051D	CODE
WRITE  . . . . . . . . . . . . .  	N PROC	04BF	CODE	Length = 0063

??0000 . . . . . . . . . . . . .  	L NEAR	0264	CODE
??0001 . . . . . . . . . . . . .  	L NEAR	0296	CODE
??0002 . . . . . . . . . . . . .  	L NEAR	02CB	CODE
??0003 . . . . . . . . . . . . .  	L NEAR	02F4	CODE
??0004 . . . . . . . . . . . . .  	L NEAR	03A6	CODE
??0005 . . . . . . . . . . . . .  	L NEAR	03F1	CODE
??0006 . . . . . . . . . . . . .  	L NEAR	0461	CODE
??0007 . . . . . . . . . . . . .  	L NEAR	05D7	CODE


    665 Source  Lines
    761 Total   Lines
    111 Symbols

  47060 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
