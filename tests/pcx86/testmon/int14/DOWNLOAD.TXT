Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Page     1-1
                                                            

                                	title	download.asm 
                                	page	,120 
                                ; 
                                ;	By Jeff Parsons (@jeffpar) 2018-03-15 
                                ;	Monitors INT 14h for file download requests 
                                ; 
                                ;	This very tiny and simplistic file downloader relies on having our 
                                ;	INT 14h	extensions TSR (INT14.COM) loaded first.  You may load INT14.COM 
                                ;	in "polled mode" (/P), but if you do, it's probably best to use the COM port 
                                ;	at its default speed of 2400 baud.  Also, if you loaded it for a non-default 
                                ;	port (/1), then make sure you run DOWNLOAD.COM with the same option (/1). 
                                ; 
                                ;	The 'protocol" is currently very fragile, and if unusual things happen 
                                ;	(eg, a block is interrupted or comes up short), we may wait indefinitely; 
                                ;	fortunately, you should always be able to press a key (eg, ESC) to abort 
                                ;	the operation and try again. 
                                ; 
                                ;	Currently, the only component that knows how to send files to DOWNLOAD.COM 
                                ;	is our Node test utility: https://www.pcjs.org/tests/pcx86/testmon/testmon.js: 
                                ; 
                                ;		node testmon.js [--baud=xxxx] 
                                ; 
                                ;	After running DOWNLOAD.COM, run testmon.js and press Ctrl-F to initiate a 
                                ;	file transfer.  You can use the DOS MODE command before running DOWNLOAD.COM 
                                ;	to specify a baud rate other than 2400, eg: 
                                ; 
                                ;		MODE COM2:9600,N,8,1 
                                ; 
                                ;	but make sure you pass the same baud rate (eg, --baud=9600) to testmon.js. 
                                ; 
 = 0400                         MAXBLK	equ	1024 
 = 000C                         MAXNAM	equ	12 
                                 
 0000                           code	segment word public 'code' 
                                 
 0100                           	org	100h 
                                 
                                	assume	cs:code, ds:code, es:code, ss:code 
                                 
 0100                           main	proc	near 
 0100  E8 02C3 R                	call	chkCOM			; verify that INT14.COM is installed 
 0103  72 05                    	jc	m1a			; abort 
                                 
 0105  E8 024F R                m1:	call	readB			; read a COM byte 
 0108  73 02                    	jnc	m2			; got one 
                                 
 010A  CD 20                    m1a:	int	20h			; abort 
                                 
 010C  3C 06                    m2:	cmp	al,06h			; Ctrl-F? 
 010E  75 F5                    	jne	m1			; no 
                                 
 0110  BA 079D R                	mov	dx,offset begXFR	; DX -> beginning transfer message 
 0113  B4 09                    	mov	ah,09h 
 0115  CD 21                    	int	21h 
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Page     1-2
                                                            

                                 
 0117  E8 0210 R                	call	readBlk			; read initial block (with file info) 
 011A  72 23                    	jc	m4a			; on error, just start over 
                                 
                                	; 
                                	; First up: the 8.3 filename (after the first '|' separator) 
                                	; 
 011C  AC                       	lodsb				; get next character 
 011D  3C 7C                    	cmp	al,'|'			; there IS a separator, right? 
 011F  75 34                    	jne	m4x			; um, no, error 
 0121  BF 0736 R                	mov	di,offset fName		; DI -> filename buffer 
 0124  B9 000C                  	mov	cx,MAXNAM		; CX == maximum filename size 
 0127  3B DE                    m3:	cmp	bx,si			; passed the end of buffer? 
 0129  72 14                    	jb	m4a			; yes, error 
 012B  AC                       	lodsb				; get next character 
 012C  3C 7C                    	cmp	al,'|'			; reached the next separator? 
 012E  74 06                    	je	m4			; yes 
 0130  49                       	dec	cx			; reached the 8.3 limit? 
 0131  7C F4                    	jl	m3			; yes, just keep looking for the separator 
 0133  AA                       	stosb				; no, save the next filename character 
 0134  EB F1                    	jmp	m3			; get more 
 0136  C6 05 00                 m4:	mov	byte ptr [di],0		; filename complete 
                                 
                                	; 
                                	; Next up: the file's size, as 8 hex digits 
                                	; 
 0139  B9 0008                  	mov	cx,8			; CX == # digits 
 013C  E8 0289 R                	call	getHex			; DS:SI -> hex digits, BX is still buffer limit 
 013F  72 14                    m4a:	jc	m4x 
 0141  A3 0743 R                	mov	fSize,ax		; AX == file size (low) 
 0144  89 16 0745 R             	mov	fSize+2,dx		; DX == file size (high) 
                                 
 0148  AC                       	lodsb				; get next character 
 0149  3C 7C                    	cmp	al,'|'			; hopefully it's a separator 
 014B  75 08                    	jne	m4x			; no, error 
                                 
                                	; 
                                	; Next up: the file's date and time, also as 8 hex digits 
                                	; 
 014D  B9 0008                  	mov	cx,8			; CX == # digits 
 0150  E8 0289 R                	call	getHex			; DS:SI -> hex digits, BX is still buffer limit 
 0153  73 03                    	jnc	m5 
 0155  E9 01E7 R                m4x:	jmp	m8err 
                                 
 0158  A3 0749 R                m5:	mov	fTime,ax		; AX == file time 
 015B  89 16 0747 R             	mov	fDate,dx		; DX == file date 
                                 
 015F  8A 04                    	mov	al,[si]			; get the FINAL character in the first block 
 0161  3C 7C                    	cmp	al,'|'			; which should be another separator 
 0163  75 F0                    	jne	m4x			; but it's not :-( 
                                 
 0165  3B DE                    	cmp	bx,si			; are we at the end of the block now? 
 0167  75 EC                    	jne	m4x			; no, something's wrong 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Page     1-3
                                                            

                                	; 
                                	; Display the filename we're about to download 
                                	; 
 0169  BA 07BD R                	mov	dx,offset doXFR		; we have enough info to begin 
 016C  B4 09                    	mov	ah,09h			; so let the user know 
 016E  CD 21                    	int	21h 
                                 
 0170  BA 0736 R                	mov	dx,offset fName		; DX -> filename 
 0173  8B CF                    	mov	cx,di			; DI still points to the end of filename 
 0175  2B CA                    	sub	cx,dx			; CX == length of filename 
 0177  BB 0001                  	mov	bx,1			; BX == STDOUT 
 017A  B4 40                    	mov	ah,40h			; display the filename 
 017C  CD 21                    	int	21h 
                                 
 017E  52                       	push	dx			; lot of work just to display a CR/LF... 
 017F  BA 07BA R                	mov	dx,offset crLF 
 0182  B4 09                    	mov	ah,09h 
 0184  CD 21                    	int	21h 
 0186  5A                       	pop	dx 
                                 
                                	; 
                                	; Create the file 
                                	; 
 0187  2B C9                    	sub	cx,cx			; CX == no special attributes 
 0189  B4 3C                    	mov	ah,3Ch			; create the file 
 018B  CD 21                    	int	21h 
 018D  72 53                    	jc	m7err 
                                 
 018F  A3 074B R                	mov	fHandle,ax 
 0192  93                       	xchg	bx,ax 
                                 
                                	; 
                                	; Start reading and writing blocks 
                                	; 
 0193  BF 0003                  m6:	mov	di,3			; DI == retries + 1 
 0196  B8 010D                  	mov	ax,010Dh		; send a Ctrl-M accepting the last block 
 0199  8B 16 0332 R             m6r:	mov	dx,comID		; and requesting the next block 
 019D  CD 14                    	int	14h			; write to COM port 
 019F  F6 C4 80                 	test	ah,80h			; error? 
 01A2  75 43                    	jnz	m8err			; yes (weird) 
 01A4  83 3E 0743 R 00          	cmp	fSize,0			; any more blocks expected? 
 01A9  75 07                    	jne	m7			; yes 
 01AB  83 3E 0745 R 00          	cmp	fSize+2,0		; well? 
 01B0  74 2B                    	je	m7end			; no, all done 
 01B2  E8 0210 R                m7:	call	readBlk			; read next block 
 01B5  73 08                    	jnc	m7a			; no error 
 01B7  B8 0112                  	mov	ax,0112h		; preload AX with Ctrl-R retry command 
 01BA  4F                       	dec	di			; any retries left? 
 01BB  75 DC                    	jnz	m6r			; yes 
 01BD  EB 28                    	jmp	short m8err		; no, report an error 
 01BF  8B CB                    m7a:	mov	cx,bx			; calculate block size 
 01C1  2B CE                    	sub	cx,si			; 
 01C3  41                       	inc	cx			; CX == total bytes (BX-SI+1) 
 01C4  29 0E 0743 R             	sub	fSize,cx		; subtract from total size 
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Page     1-4
                                                            

 01C8  83 1E 0745 R 00          	sbb	fSize+2,0		; 
 01CD  72 18                    	jc	m8err			; file size error (too MUCH data?) 
 01CF  8B 1E 074B R             	mov	bx,fHandle		; BX == handle 
 01D3  8B D6                    	mov	dx,si			; DS:DX -> block buffer 
 01D5  B4 40                    	mov	ah,40h			; write to file 
 01D7  CD 21                    	int	21h			; 
 01D9  72 07                    	jc	m7err			; file write failed 
 01DB  EB B6                    	jmp	m6			; read next block 
                                 
                                	; 
                                	; Download complete; close the file and print message 
                                	; 
 01DD  BA 07D0 R                m7end:	mov	dx,offset endXFR 
 01E0  EB 08                    	jmp	short m9 
                                 
                                	; 
                                	; Assorted error paths (make sure any open file gets closed) 
                                	; 
 01E2  BA 07E9 R                m7err:	mov	dx,offset filErr 
 01E5  EB 03                    	jmp	short m9 
                                 
 01E7  BA 0801 R                m8err:	mov	dx,offset reqErr 
                                 
                                	; 
                                	; TODO: If the message isn't endXFR, perhaps we should delete the file 
                                	; 
 01EA  8B 1E 074B R             m9:	mov	bx,fHandle 
 01EE  85 DB                    	test	bx,bx 
 01F0  74 17                    	jz	m9msg 
 01F2  8B 0E 0749 R             	mov	cx,fTime		; before we close the file 
 01F6  8B 16 0747 R             	mov	dx,fDate		; set the date/time we were given 
 01FA  B8 5701                  	mov	ax,5701h 
 01FD  CD 21                    	int	21h 
 01FF  B4 3E                    	mov	ah,3Eh			; now go ahead and close 
 0201  CD 21                    	int	21h 
 0203  C7 06 074B R 0000        	mov	fHandle,0 
                                 
 0209  B4 09                    m9msg:	mov	ah,09h 
 020B  CD 21                    	int	21h 
 020D  E9 0105 R                	jmp	m1 
                                main	endp 
                                 
                                ; 
                                ; Read a block of data into our block buffer. 
                                ; 
                                ; If successful, CARRY is clear and SI and BX contain the block boundaries. 
                                ; 
 0210                           readBlk	proc	near 
 0210  51                       	push	cx 
 0211  57                       	push	di 
                                 
 0212  E8 026E R                	call	readBB			; read block byte 
 0215  72 35                    	jc	rblk9			; error, pass it on to caller 
 0217  8A C8                    	mov	cl,al 
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Page     1-5
                                                            

 0219  E8 026E R                	call	readBB 
 021C  72 2E                    	jc	rblk9 
 021E  8A E8                    	mov	ch,al			; CX now has 16-bit block length 
 0220  81 F9 0401               	cmp	cx,MAXBLK+1		; too large? 
 0224  F5                       	cmc 
 0225  72 25                    	jc	rblk9			; yes 
 0227  8B F1                    	mov	si,cx			; save block length in SI 
 0229  B4 00                    	mov	ah,0			; AH == CRC 
 022B  FC                       	cld 
 022C  BF 0336 R                	mov	di,offset block		; DI -> block buffer 
 022F  E8 026E R                rblk1:	call	readBB			; read a byte 
 0232  72 18                    	jc	rblk9			; exit on error 
 0234  AA                       	stosb				; save the byte 
 0235  02 E0                    	add	ah,al			; update the CRC 
 0237  E2 F6                    	loop	rblk1			; loop for more 
 0239  E8 026E R                	call	readBB			; read one more byte: the CRC byte 
 023C  72 0E                    	jc	rblk9 
 023E  3A C4                    	cmp	al,ah			; CRC match? 
 0240  F9                       	stc 
 0241  75 09                    	jne	rblk9			; no 
                                 
 0243  8B DE                    	mov	bx,si 
 0245  BE 0336 R                	mov	si,offset block		; SI is starting block address 
 0248  03 DE                    	add	bx,si 
 024A  4B                       	dec	bx			; and BX is the maximum block address 
 024B  F8                       	clc 
                                 
 024C  5F                       rblk9:	pop	di 
 024D  59                       	pop	cx 
 024E  C3                       	ret 
                                readBlk	endp 
                                 
                                ; 
                                ; Read a character from the COM port. 
                                ; 
                                ; If CARRY is clear, AL has the character.  No other registers modified. 
                                ; 
 024F                           readB	proc	near 
 024F  51                       	push	cx 
 0250  52                       	push	dx 
 0251  91                       	xchg	cx,ax			; save AH (in CH) 
                                 
 0252  8B 16 0332 R             rb1:	mov	dx,comID		; DX == adapter # 
 0256  B4 02                    	mov	ah,2			; AH == read request 
 0258  CD 14                    	int	14h			; do INT 14h 
 025A  84 E4                    	test	ah,ah			; anything (valid) available yet? 
 025C  74 0B                    	jz	rb9			; yes (and CARRY is clear) 
                                 
 025E  B4 01                    	mov	ah,1			; peek the keyboard 
 0260  CD 16                    	int	16h			; anything? 
 0262  74 EE                    	jz	rb1			; no 
 0264  3C 1B                    	cmp	al,1Bh			; ESC? 
 0266  75 EA                    	jne	rb1			; no 
 0268  F9                       	stc				; set CARRY to indicate error/abort 
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Page     1-6
                                                            

                                 
 0269  8A E5                    rb9:	mov	ah,ch			; restore AH 
 026B  5A                       	pop	dx 
 026C  59                       	pop	cx 
 026D  C3                       	ret 
                                readB	endp 
                                 
                                ; 
                                ; Read a block byte from the COM port. 
                                ; 
                                ; If CARRY is clear, AL has the character.  No other registers modified. 
                                ; 
 026E                           readBB	proc	near 
 026E  E8 024F R                	call	readB			; read a byte 
 0271  72 15                    	jc	rbb9			; abort 
 0273  3C 5E                    	cmp	al,'^'			; control character lead byte? 
 0275  F8                       	clc				; 
 0276  75 10                    	jne	rbb9			; no, return as-is 
 0278  E8 024F R                	call	readB			; read another byte 
 027B  72 0B                    	jc	rbb9			; abort 
 027D  3C 5E                    	cmp	al,'^'			; special double lead byte sequence? 
 027F  74 07                    	je	rbb9			; yes, pass through 
 0281  2C 40                    	sub	al,'@' 
 0283  72 03                    	jb	rbb9			; invalid sequence 
 0285  3C 1C                    	cmp	al,28			; in the control-character range? 
 0287  F5                       	cmc				; set carry if not 
 0288  C3                       rbb9:	ret 
                                readBB	endp 
                                 
                                ; 
                                ; Get CX hex characters from the block buffer at SI (up to BX) and convert to a number i
				n DX:AX. 
                                ; 
 0289                           getHex	proc	near 
 0289  57                       	push	di 
 028A  2B C0                    	sub	ax,ax 
 028C  2B FF                    	sub	di,di 
 028E  2B D2                    	sub	dx,dx			; DX:DI will accumulate the result 
                                 
 0290  FC                       	cld 
 0291  3B DE                    gh1:	cmp	bx,si			; still in bounds? 
 0293  72 2C                    	jb	gh9			; no 
 0295  AC                       	lodsb 
 0296  2C 30                    	sub	al,'0' 
 0298  72 27                    	jb	gh9			; error, invalid digit 
 029A  3C 0A                    	cmp	al,10			; was the digit 0-9? 
 029C  72 0B                    	jb	gh2			; yes 
 029E  2C 07                    	sub	al,'A'-'0'-10		; assuming it was A-F, subtract a bit more 
 02A0  3C 0A                    	cmp	al,10			; did we get 10-15 as a result? 
 02A2  72 1D                    	jb	gh9			; no 
 02A4  3C 10                    	cmp	al,16 
 02A6  F5                       	cmc 
 02A7  72 18                    	jb	gh9 
 02A9  0B F8                    gh2:	or	di,ax 
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Page     1-7
                                                            

 02AB  49                       	dec	cx 
 02AC  7E 12                    	jle	gh8 
 02AE  D1 E7                    	shl	di,1			; shift DX:DI left 4 bits for next digit 
 02B0  D1 D2                    	rcl	dx,1 
 02B2  D1 E7                    	shl	di,1 
 02B4  D1 D2                    	rcl	dx,1 
 02B6  D1 E7                    	shl	di,1 
 02B8  D1 D2                    	rcl	dx,1 
 02BA  D1 E7                    	shl	di,1 
 02BC  D1 D2                    	rcl	dx,1 
 02BE  EB D1                    	jmp	gh1 
                                 
 02C0  97                       gh8:	xchg	ax,di			; result is now in DX:AX 
                                 
 02C1  5F                       gh9:	pop	di 
 02C2  C3                       	ret 
                                getHex	endp 
                                 
                                ; 
                                ; Check for a /1 or /2 to determine which adapter we should monitor. 
                                ; 
 02C3                           chkCom	proc	near 
 02C3  FC                       	cld 
 02C4  BE 0080                  	mov	si,80h			; DS:SI -> command line 
 02C7  AC                       	lodsb 
 02C8  98                       	cbw 
 02C9  91                       	xchg	cx,ax			; CX == line length (as a fail-safe) 
 02CA  AC                       chk1:	lodsb 
 02CB  49                       	dec	cx 
 02CC  3C 0D                    	cmp	al,0Dh			; end of command-line? 
 02CE  74 14                    	je	chk3			; yes 
 02D0  3C 2F                    	cmp	al,'/' 
 02D2  75 0C                    	jne	chk2 
 02D4  AC                       	lodsb 
 02D5  49                       	dec	cx 
 02D6  3C 31                    	cmp	al,'1'			; /1? 
 02D8  75 06                    	jne	chk2			; no 
 02DA  81 06 0334 R 0100        	add	comAddr,100h		; bump 2F8h to 3F8h 
 02E0  85 C9                    chk2:	test	cx,cx			; any more command-line characters? 
 02E2  7F E6                    	jg	chk1			; yes 
                                 
 02E4  06                       chk3:	push	es 
 02E5  2B C0                    	sub	ax,ax 
 02E7  8E C0                    	mov	es,ax 
                                	assume	es:nothing		; since ES is zero 
                                 
 02E9  A1 0334 R                	mov	ax,comAddr 
 02EC  BB 0400                  	mov	bx,400h			; access RBDA @0:400 instead of 40:0 
 02EF  2B D2                    	sub	dx,dx 
 02F1  26: 39 07                chk4:	cmp	word ptr es:[bx],ax	; matching port? 
 02F4  74 12                    	je	chk5			; yes 
 02F6  43                       	inc	bx 
 02F7  43                       	inc	bx 
 02F8  42                       	inc	dx 
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Page     1-8
                                                            

 02F9  80 FA 04                 	cmp	dl,4 
 02FC  72 F3                    	jb	chk4 
 02FE  BA 0788 R                	mov	dx,offset errMsg	; no matching port was found; abort 
 0301  B4 09                    	mov	ah,09h 
 0303  CD 21                    	int	21h 
 0305  F9                       	stc 
 0306  EB 28                    	jmp	short chk9 
                                 
 0308  89 16 0332 R             chk5:	mov	comID,dx		; comID is 0 for COM1, 1 for COM2, etc. 
 030C  B4 AA                    	mov	ah,0AAh			; quick-and-dirty INT14.COM installation check 
 030E  CD 14                    	int	14h 
 0310  F6 D4                    	not	ah 
 0312  80 FC AA                 	cmp	ah,0AAh 
 0315  74 0A                    	je	chk6 
 0317  BA 075E R                	mov	dx,offset chkMsg	; INT14.COM needs to be installed for that port first 
 031A  B4 09                    	mov	ah,09h 
 031C  CD 21                    	int	21h 
 031E  F9                       	stc 
 031F  EB 0F                    	jmp	short chk9 
                                 
 0321  80 C2 31                 chk6:	add	dl,'1' 
 0324  88 16 0750 R             	mov	comMsg+3,dl 
 0328  BA 074D R                	mov	dx,offset comMsg 
 032B  B4 09                    	mov	ah,09h 
 032D  CD 21                    	int	21h 
 032F  F8                       	clc 
                                 
 0330  07                       chk9:	pop	es 
                                	assume	es:code 
 0331  C3                       	ret 
                                chkCOM	endp 
                                 
 0332  FFFF                     comID	dw	-1			; 0-based index of COM port in BIOS data area 
 0334  02F8                     comAddr	dw	2F8h 
                                 
 0336  0400[                    block	db	MAXBLK dup (?) 
            ??                  
                         ]      
                                
 0736  000D[                    fName	db	MAXNAM+1 dup (0)	; enough space for an 8.3 name plus terminating NUL 
            00                  
                         ]      
                                
 0743  0000 0000                fSize	dw	0,0 
 0747  0000                     fDate	dw	0 
 0749  0000                     fTime	dw	0 
 074B  0000                     fHandle	dw	0 
                                 
 074D  43 4F 4D 3F 20 6D 6F     comMsg	db	"COM? monitored",13,10,'$' 
       6E 69 74 6F 72 65 64     
       0D 0A 24                 
 075E  52 75 6E 20 49 4E 54     chkMsg	db	"Run INT14 to install I/O handlers first",13,10,'$' 
       31 34 20 74 6F 20 69     
       6E 73 74 61 6C 6C 20     
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Page     1-9
                                                            

       49 2F 4F 20 68 61 6E     
       64 6C 65 72 73 20 66     
       69 72 73 74 0D 0A 24     
 0788  43 4F 4D 20 70 6F 72     errMsg	db	"COM port not found",13,10,'$' 
       74 20 6E 6F 74 20 66     
       6F 75 6E 64 0D 0A 24     
                                 
 079D  52 65 63 65 69 76 69     begXFR	db	"Receiving transfer request..." 
       6E 67 20 74 72 61 6E     
       73 66 65 72 20 72 65     
       71 75 65 73 74 2E 2E     
       2E                       
 07BA  0D 0A 24                 crLF	db	13,10,'$' 
 07BD  44 6F 77 6E 6C 6F 61     doXFR	db	"Downloading file: $" 
       64 69 6E 67 20 66 69     
       6C 65 3A 20 24           
 07D0  46 69 6C 65 20 74 72     endXFR	db	"File transfer complete",13,10,'$' 
       61 6E 73 66 65 72 20     
       63 6F 6D 70 6C 65 74     
       65 0D 0A 24              
                                 
 07E9  55 6E 61 62 6C 65 20     filErr	db	"Unable to create file",13,10,'$' 
       74 6F 20 63 72 65 61     
       74 65 20 66 69 6C 65     
       0D 0A 24                 
 0801  49 6E 76 61 6C 69 64     reqErr	db	"Invalid transfer request",13,10,'$' 
       20 74 72 61 6E 73 66     
       65 72 20 72 65 71 75     
       65 73 74 0D 0A 24        
                                 
 081C                           code	ends 
                                 
                                	end	main 
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Symbols-1
                                                             

Segments and Groups:

                N a m e         	Size	Align	Combine Class

CODE . . . . . . . . . . . . . .  	081C	WORD	PUBLIC	'CODE'

Symbols:            

                N a m e         	Type	Value	Attr         

BEGXFR . . . . . . . . . . . . .  	L BYTE 	079D	CODE
BLOCK  . . . . . . . . . . . . .  	L BYTE 	0336	CODE	Length = 0400

CHK1 . . . . . . . . . . . . . .  	L NEAR	02CA	CODE
CHK2 . . . . . . . . . . . . . .  	L NEAR	02E0	CODE
CHK3 . . . . . . . . . . . . . .  	L NEAR	02E4	CODE
CHK4 . . . . . . . . . . . . . .  	L NEAR	02F1	CODE
CHK5 . . . . . . . . . . . . . .  	L NEAR	0308	CODE
CHK6 . . . . . . . . . . . . . .  	L NEAR	0321	CODE
CHK9 . . . . . . . . . . . . . .  	L NEAR	0330	CODE
CHKCOM . . . . . . . . . . . . .  	N PROC	02C3	CODE	Length = 006F
CHKMSG . . . . . . . . . . . . .  	L BYTE 	075E	CODE
COMADDR  . . . . . . . . . . . .  	L WORD 	0334	CODE
COMID  . . . . . . . . . . . . .  	L WORD 	0332	CODE
COMMSG . . . . . . . . . . . . .  	L BYTE 	074D	CODE
CRLF . . . . . . . . . . . . . .  	L BYTE 	07BA	CODE

DOXFR  . . . . . . . . . . . . .  	L BYTE 	07BD	CODE

ENDXFR . . . . . . . . . . . . .  	L BYTE 	07D0	CODE
ERRMSG . . . . . . . . . . . . .  	L BYTE 	0788	CODE

FDATE  . . . . . . . . . . . . .  	L WORD 	0747	CODE
FHANDLE  . . . . . . . . . . . .  	L WORD 	074B	CODE
FILERR . . . . . . . . . . . . .  	L BYTE 	07E9	CODE
FNAME  . . . . . . . . . . . . .  	L BYTE 	0736	CODE	Length = 000D
FSIZE  . . . . . . . . . . . . .  	L WORD 	0743	CODE
FTIME  . . . . . . . . . . . . .  	L WORD 	0749	CODE

GETHEX . . . . . . . . . . . . .  	N PROC	0289	CODE	Length = 003A
GH1  . . . . . . . . . . . . . .  	L NEAR	0291	CODE
GH2  . . . . . . . . . . . . . .  	L NEAR	02A9	CODE
GH8  . . . . . . . . . . . . . .  	L NEAR	02C0	CODE
GH9  . . . . . . . . . . . . . .  	L NEAR	02C1	CODE

M1 . . . . . . . . . . . . . . .  	L NEAR	0105	CODE
M1A  . . . . . . . . . . . . . .  	L NEAR	010A	CODE
M2 . . . . . . . . . . . . . . .  	L NEAR	010C	CODE
M3 . . . . . . . . . . . . . . .  	L NEAR	0127	CODE
M4 . . . . . . . . . . . . . . .  	L NEAR	0136	CODE
M4A  . . . . . . . . . . . . . .  	L NEAR	013F	CODE
M4X  . . . . . . . . . . . . . .  	L NEAR	0155	CODE
M5 . . . . . . . . . . . . . . .  	L NEAR	0158	CODE
M6 . . . . . . . . . . . . . . .  	L NEAR	0193	CODE
Microsoft (R) Macro Assembler  Version 4.00                 3/16/18 09:43:15

download.asm                                                Symbols-2
                                                             

M6R  . . . . . . . . . . . . . .  	L NEAR	0199	CODE
M7 . . . . . . . . . . . . . . .  	L NEAR	01B2	CODE
M7A  . . . . . . . . . . . . . .  	L NEAR	01BF	CODE
M7END  . . . . . . . . . . . . .  	L NEAR	01DD	CODE
M7ERR  . . . . . . . . . . . . .  	L NEAR	01E2	CODE
M8ERR  . . . . . . . . . . . . .  	L NEAR	01E7	CODE
M9 . . . . . . . . . . . . . . .  	L NEAR	01EA	CODE
M9MSG  . . . . . . . . . . . . .  	L NEAR	0209	CODE
MAIN . . . . . . . . . . . . . .  	N PROC	0100	CODE	Length = 0110
MAXBLK . . . . . . . . . . . . .  	Number	0400	
MAXNAM . . . . . . . . . . . . .  	Number	000C	

RB1  . . . . . . . . . . . . . .  	L NEAR	0252	CODE
RB9  . . . . . . . . . . . . . .  	L NEAR	0269	CODE
RBB9 . . . . . . . . . . . . . .  	L NEAR	0288	CODE
RBLK1  . . . . . . . . . . . . .  	L NEAR	022F	CODE
RBLK9  . . . . . . . . . . . . .  	L NEAR	024C	CODE
READB  . . . . . . . . . . . . .  	N PROC	024F	CODE	Length = 001F
READBB . . . . . . . . . . . . .  	N PROC	026E	CODE	Length = 001B
READBLK  . . . . . . . . . . . .  	N PROC	0210	CODE	Length = 003F
REQERR . . . . . . . . . . . . .  	L BYTE 	0801	CODE


    434 Source  Lines
    434 Total   Lines
     80 Symbols

  48242 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
